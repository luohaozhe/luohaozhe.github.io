[{"id":"8f98f95190bf6f9aef227316ecc3abb6","title":"谢谢你这么可爱来看我","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-08-15T02:02:21.339Z","categories_index":"","tags_index":"","author_index":"Luo"},{"id":"b1d4275db085b7ee39b2c5b4a055dbff","title":"ES6","content":"ES6语法let关键字1.申明变量与赋值\neg：let a &#x3D; 100\n2.特性:不能重复申明\n3.作用域（let：块级作用域在代码块里面有效）\n4.不影响作用域链\n\nconst 关键字const定义常量(值不发生改变的量)\neg：const name &#x3D; &#39;luochaoyue&#39;;\n1.一定要赋初始值\n2.常量的值不能修改\n3.块级作用域\n4.对于数组和对象元素的修改不算做对常量的修改\n\n\n解构赋值ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值\n数组解构\neg：\nconst F4 &#x3D; [&quot;吴亦凡&quot;, &quot;李易峰&quot;, &quot;王一博&quot;, &quot;陈飞宇&quot;];\n      let [wu, li, wang, chen] &#x3D; F4;\n      console.log(wu, li, wang, chen);\n对象解构\neg：\n&#x2F;&#x2F; 对象结构\n    const F4 &#x3D;&#123;\n        name: &#39;吴亦凡&#39;,\n        age: &#39;30&#39;,\n        music: function () &#123;\n            console.log(&#39;大碗宽面&#39;);\n        &#125;\n    &#125;;\n    let &#123;name, age, music&#125; &#x3D; F4;\n    console.log(name);\n    console.log(age);\n    console.log(music);\n    music();\n\n模板字符串eg：\nlet str &#96;我是一个字符串&#96;\n1.内容中可以直接出现换行符\n2.字符串拼接\neg：\nlet iode &#x3D; &#96;肖战&#96;;\n        let msfg &#x3D; &#96;$&#123;iode&#125;是我的偶像&#96;\n        console.log(msfg);\n3.\n\n简化对象写法let name &#x3D; &#39;蔡徐坤&#39;\n        let change &#x3D; function() &#123;\n            console.log(&#39;唱跳, RAP 篮球&#39;)\n        &#125;\n        \n        const ideo &#x3D; &#123;\n             name,\n             change,\n             imporve() &#123;\n                console.log(&#39;我们一起打篮球&#39;);\n\n             &#125;\n        &#125;\n        console.log(name, change);\n\n箭头函数#eg：\n let sun &#x3D; (a,b)&#x3D;&gt; &#123;\n           return a + b;\n\n      &#125;\n      let result &#x3D; fn(1,2)\n      console.log(result);\n1.this是静态的(this始终指向函数声明时所在作用域下this的值)\n eg：\n &#x2F;&#x2F;普通函数\n    let getname &#x3D; function () &#123;\n          console.log(this.name);\n    &#125;;\n    &#x2F;&#x2F;箭头函数\n    let getname2 &#x3D; () &#x3D;&gt; &#123;\n        console.log(this.name);\n    &#125;\n    &#x2F;&#x2F; 设置window对象的name属性\n    window.name &#x3D; &#39;罗超越&#39;;\n    &#x2F;&#x2F;设置对象的name属性\n    const school &#x3D; &#123;\n        name: &#39;洛昊哲&#39;\n    &#125;\n    &#x2F;&#x2F; 直接调用\n    &#x2F;&#x2F; getname();\n    &#x2F;&#x2F; getname2();\n    &#x2F;&#x2F;  call 调用\n    getname.call(school);\n    getname2.call(school);\n  \n  2.不能作为构造函数实例化对象\n  eg：\n    let person &#x3D; (name, age) &#x3D;&gt; &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n\n    &#125; \n    let me &#x3D; new person(&#39;xaio&#39;,30);\n    console.log(me)\n    \n3.不能使用arguments变量\n\n4.箭头函数适合于this无关的回调 如定时器，数组的方法回调\n不适合与this有关的回调如 点击事件回调 对象的方法\n\n允许给函数参数赋值初始值let sun &#x3D; (a &#x3D; 1,b &#x3D; 2) &#x3D;&gt;&#123;\n            return a + b;\n       &#125;\n       let result &#x3D; sun();\n       console.log(result);\n\nrest参数ES6 引入rest参数用函数的实参，用来代替argumnet\n &#x2F;&#x2F;返回对象\n       function date() &#123;\n       console.log(arguments);\n       &#125;\n       date(&#39;zhangbaizhi&#39;, &#39;lingzujxian&#39;, &#39;zhanaas&#39;);\n\n  &#x2F;&#x2F;返回数组  可调用数组方法\n      function date(...args)&#123;\n        console.log(args);   &#x2F;&#x2F;filte some every map \n    &#125;\n       date(&#39;冰冰&#39;,&#39;白芷&#39;,&#39;傲娇&#39;);\n       \n注意: rest参数必须放到参数的最后\n\n\n扩展运算符[...]\nconst colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;black&#39;, &#39;pink&#39;];\n    const andomon &#x3D; [&#39;你的名字&#39;, &#39;天气之子&#39;, &#39;千与千寻&#39;, &#39;龙猫&#39;];\n    const hebin &#x3D;colors.concat(andomon);\n    console.log(hebin);\n    &#x2F;&#x2F;扩展运算符的使用 \n    &#x2F;&#x2F; 1.数组的合并\n    const hebins &#x3D; [...colors, ...andomon];\n    console.log(&#39;hebins&#39;);\n    &#x2F;&#x2F;2.数组的克隆\n    const an &#x3D; [...andomon];\n    console.log(an);\n    &#x2F;&#x2F; 将伪数组转化为真正的数组\n  const divs &#x3D; document.querySelectorAll(&#39;div&#39;)\n  console.log(divs);\n  const divss &#x3D; [...divs];\n  console.log(divss);\n\nsymbolES6引入的一种新的原始数据类型 表示独一无二的值\n创建\nlet s1 &#x3D; Symbol();\n1.值是唯一的---用来解决命名冲突的问题\n2.值不能与其他数据进行运算\n3.定义的对象属性不能用for....in遍历循环但可以使用Reflect.ownKEys\n来获取对象的所用键名\n\n &#x2F;&#x2F;创建函数\n        let s1 &#x3D; Symbol();\n        console.log(s1, typeof s1);\n        let s2 &#x3D; Symbol(&#39;罗超越&#39;);\n        let s3 &#x3D; Symbol(&#39;罗超越&#39;);\n       console.log(s2 &#x3D;&#x3D;&#x3D; s3);\n       &#x2F;&#x2F;创建对象\n       let s4 &#x3D; Symbol.for(&#39;罗超越&#39;)\n       let s5 &#x3D; Symbol.for(&#39;罗超越&#39;)\n\n       console.log(s4 &#x3D;&#x3D;&#x3D; s5);\n4.使用(向对象添加属性和方法)\neg：\n let youxi &#x3D; &#123;\n        name: &#39;狼人杀&#39;,\n        [Symbol(&#39;say&#39;)]: function () &#123;\n            console.log(&#39;我可以说话&#39;);\n        &#125;,\n        [Symbol(&#39;zibao&#39;)]: function() &#123;\n            console.log(&#39;我可以自爆&#39;);\n        &#125;\n      &#125;\n        console.log(youxi);\n5.Symbol内置值\nclass person&#123;\n   satatic[Symbol.hasInstance()&#123;\n   console.log(&#39;我被用来检测类型了&#39;)];2\n&#125;\n\n数据类型(记忆)USONB   you are so niubility\nU  undefined\nS  string Symbol\nO 　object\nN　number\nB boolean\n\n\n迭代器（Iterator）是一种接口,为不同的数据结构提供统一的访问机制\n\n任何数据结构只要部署iterator接口(对象里面的一个属性)，就可以完成遍历操作\n1.新的遍历命令 for ...of 循环\n原生具备iterator接口的数据可使用for....of(遍历)\nArray\nArguments\nSet\nMap\nString\nTypedArray\nNodeLIst\n\n自定义遍历数据生成器&#x2F;&#x2F;模拟数据 用户数据 &#x3D;&gt; 订单数据 &#x3D;&gt;商品数据 依次一秒后输出\n        function getUser() &#123;\n             setTimeout(()&#x3D;&gt; &#123;\n                let data &#x3D; &#39;用户数据&#39;;\n                &#x2F;&#x2F;调用next() 方法并将data传入\n                iterator.next(data);\n             &#125; ,1000);\n        &#125;\n\n        function getOrder() &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                let data  &#x3D; &#39;订单数据&#39;;\n                iterator.next(data);\n            &#125;, 1000);\n        &#125;\n\n        function getGoods() &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                let data &#x3D; &#39;商品数据&#39;;\n                iterator.next(data);\n            &#125;, 1000);\n        &#125;\n\n        function * gen () &#123;\n          let user &#x3D; yield getUser();\n          console.log(user);\n          let order &#x3D;  yield getOrder();\n          console.log(order);\n           let goos &#x3D; yield getGoods()\n           console.log(goos);\n        &#125;\n\n        &#x2F;&#x2F; 调用生成器函数\n        let iterator &#x3D; gen();\n        iterator.next();  &#x2F;&#x2F;运行第一段代码\n\n\nPromisePromise是ES6引入的异步编程的新解决方案\n语法上它是一个构造函数\n用来封装异步操作并可以获取其成功或失败的结果\neg：\n let myPromise &#x3D; new Promise(function(myResolve, myReject) &#123;\n&#x2F;&#x2F; &quot;Producing Code&quot;（可能需要一些时间）\n    setTimeout(() &#x3D;&gt; &#123;\n    let data &#x3D; &#39;数据库中的用户数据&#39;;  \n    &#x2F;&#x2F; console.log(data); \n    myResolve(data);\n    &#125;, 1000);\n    setTimeout(() &#x3D;&gt; &#123;\n    let err &#x3D; &#39;数据出错了&#39;;\n    &#x2F;&#x2F; console.log(err);\n    myReject(err);\n    &#125;,1000);\n&#125;);\n\n&#x2F;&#x2F; &quot;Consuming Code&quot; （必须等待一个兑现的承诺）\nmyPromise.then(\n  function(value) &#123; console.log(value);&#125;,\n  function(error) &#123; console.log(error);&#125;\n);\n\n2.读取文件\neg：\n&#x2F;&#x2F;引入fs规则\nconst fs &#x3D; require(&#39;fs&#39;);\n\n&#x2F;&#x2F;调用方法读取文件\nfs.readFile(&#39;.&#x2F;resuorces&#x2F;suiji.md&#39;,(err,data) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;如果失败则抛出错误\n    if(err) throw err;\n    &#x2F;&#x2F;如果没有出错则输出这个内容\n    console.log(data.toString());\n&#125;);\n\n\n使用Promise封装AJAX请求&#x2F;&#x2F; 使用Promise封装AJAx请求\n        &#x2F;&#x2F;创建promise对象\n        const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n        \n             &#x2F;&#x2F; 创建对象AJAX请求对象\n        const xhr &#x3D; new XMLHttpRequest();\n        &#x2F;&#x2F;初始化\n        xhr.open(&quot;GET&quot;, &#39;https:&#x2F;&#x2F;api.apiopen&#x2F;getJoke&#39;);\n        &#x2F;&#x2F;发请求\n        xhr.send();\n        &#x2F;&#x2F;绑定事件 回调函数\n        xhr.onreadystatechange &#x3D; function() &#123;\n            if(xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n                if(xhr.status  &gt;&#x3D; 200 &amp;&amp; xhr.status &gt; 300)&#123;\n                    resolve(xhr.response);\n                &#125;else&#123;\n                    reject(xhr.status);\n                &#125;\n            &#125;\n        &#125;       \n        &#125;); \n        &#x2F;&#x2F; 指定成功失败的回调\n        p.then(function(value)&#123;\n            console.log(value);\n        &#125;,function(reason)&#123;\n            console.error(reason);\n        &#125;);\n\nPromise.prototype.then方法&#x2F;&#x2F; 创建Promise对象\n        const P &#x3D; new Promise ((resolve, reject) &#x3D;&gt; &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                &#x2F;&#x2F;成功的数据\n                resolve(&#39;成功的数据&#39;);\n                \n            &#125;,1000);\n            setTimeout(() &#x3D;&gt; &#123;\n               &#x2F;&#x2F;失败的数据\n               reject(&#39;失败的数据&#39;);\n            &#125;,2000)\n        &#125;);\n           &#x2F;&#x2F;通过p.then()方法处理回调\n        &#x2F;&#x2F;    P.then(function(value) &#123;\n        &#x2F;&#x2F;          console.log(value);\n        &#x2F;&#x2F;    &#125;,function(reason) &#123;\n        &#x2F;&#x2F;          console.error(reason);\n        &#x2F;&#x2F;    &#125;);\n        &#x2F;&#x2F;   1. p.then() 的返回结果也是一个Promise 他的状态结果由回调函数里面执行结果决定\n        &#x2F;&#x2F;   2.如果回调函数中返回的结果 为非Promise类型的属性， 状态为成功 放回值为对象中成功的值\n        &#x2F;&#x2F;   3.抛出错误 状态也为reject 值为抛出错误里面的值\n        &#x2F;&#x2F;   所以Promise是可以链式调用的\n        &#x2F;&#x2F; const result &#x3D; P.then(value &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     console.log(value);\n        &#x2F;&#x2F;     &#x2F;&#x2F;2.非Promise的情况\n        &#x2F;&#x2F;     &#x2F;&#x2F; return &#39;i love you&#39;\n        &#x2F;&#x2F;     &#x2F;&#x2F;返回的值是一个Promise值\n        &#x2F;&#x2F;     &#x2F;&#x2F; return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     &#x2F;&#x2F;     resolve(&#39;ok&#39;); &#x2F;&#x2F;决定外面Promise的状态为resolve 值为ok\n        &#x2F;&#x2F;     &#x2F;&#x2F; &#125;);\n        &#x2F;&#x2F;     &#x2F;&#x2F; 3.抛出错误\n        &#x2F;&#x2F;     &#x2F;&#x2F; throw new Error(&#39;出错啦!!!&#39;)\n\n        &#x2F;&#x2F; &#125;, reason &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     console.error(reason);\n        &#x2F;&#x2F; &#125;);\n\n\n        &#x2F;&#x2F; 链式调用 失败回调可省略\n        p.then(value &#x3D;&gt; &#123;\n\n        &#125;).then(value &#x3D;&gt; &#123;\n\n        &#125;);\n        console.log(result);\n\npromise 链式调用&#x2F;&#x2F;基础方法  实现多个文件读取合并输出\n&#x2F;&#x2F;    fs.readFile(&#39;.&#x2F;resuorces&#x2F;剑来.md&#39;, (err, data1) &#x3D;&gt; &#123;\n&#x2F;&#x2F;       fs.readFile(&#39;.&#x2F;resuorces&#x2F;烽火戏诸侯.md&#39;, (err, data2) &#x3D;&gt; &#123;\n&#x2F;&#x2F;          fs.readFile(&#39;.&#x2F;resuorces&#x2F;大奉打更人.md&#39;, (err, data3) &#x3D;&gt; &#123;\n&#x2F;&#x2F;             let result &#x3D; data1 + &#39;\\r\\n&#39; + data2 +&#39;\\r\\n&#39; + data3;\n&#x2F;&#x2F;              console.log(result);\n&#x2F;&#x2F;           &#125;);\n&#x2F;&#x2F;       &#125;);\n&#x2F;&#x2F;  &#125;);\n\n&#x2F;&#x2F;使用 promise 实现\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n   fs.readFile(&quot;.&#x2F;resuorces&#x2F;剑来.md&quot;, (err, data) &#x3D;&gt; &#123;\n      resolve(data);\n   &#125;);\n&#125;);\n\np.then(value &#x3D;&gt; &#123;\n   return new Promise((resolve,reject) &#x3D;&gt; &#123;\n\n \n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;大奉打更人.md&quot;, (err,data) &#x3D;&gt; &#123;\n        resolve([value, data]);\n        \n    &#125;);\n&#x2F;&#x2F;    console.log(value.toString());\n&#125;);\n&#125;).then(value &#x3D;&gt; &#123;\n   return new Promise((resolve,reject) &#x3D;&gt; &#123;\n\n  \n   fs.readFile(&quot;.&#x2F;resuorces&#x2F;烽火戏诸侯.md&quot;,(err,data) &#x3D;&gt; &#123;\n      value.push(data);\n      resolve(value);\n   &#125;)\n&#125;);\n&#125;).then(value &#x3D;&gt; &#123;\n   console.log(value.join(&#39;\\r\\n&#39;));\n&#125;)\n\n\npromise catch() 方法const p  &#x3D; new  Promise((resolve, reject) &#x3D;&gt; &#123;\n            &#x2F;&#x2F;定时器\n            setTimeout(() &#x3D;&gt; &#123;\n                &#x2F;&#x2F;设置p对象的状态为失败 并设置失败的值\n                 reject(&#39;出错啦！！！&#39;);\n            &#125;, 1000);\n        &#125;);\n        &#x2F;&#x2F;p.then()方法\n        p.then(value &#x3D;&gt; &#123;\n\n        &#125;, reason &#x3D;&gt; &#123;\n            console.error(reason);\n        &#125;);\n\n        &#x2F;&#x2F; p.catch() 方法\n        p.catch(function(reason)&#123;\n            console.warn(reason);\n        &#125;)\n\nSet 数据结构set(集合)它类似于数组，但成员的值都是唯一的\n实现了iteration 可使用扩展运算符[...] 和 for of 遍历\n1.size  返回结合的元素个数\n2.add 增加一个新元素 返回当前集合\n3.delete 删除元素 返回boolean值\n4.has 检测集合中是否包含某个元素  返回boolean值\n5.clear 清空内容\neg：\n &lt;!-- 声明一个Set()  --&gt;\n    &lt;script&gt;\n      let s &#x3D; new Set();\n      &#x2F;&#x2F;参数 --可迭代数据 --一般为数组 不可重複 自動去重\n      let s2 &#x3D; new Set([&quot;秀倩&quot;, &quot;杨千幻&quot;, &quot;秀新年&quot;, &quot;秀倩&quot;]);\n      &#x2F;&#x2F;添加集合元素\n      s2.add(&#39;威亞是你&#39;);\n      &#x2F;&#x2F;刪除元素\n       s2.delete(&#39;秀倩&#39;);\n    \n     \n      console.log(s, typeof s);\n      console.log(s2);\n      &#x2F;&#x2F;元素個數\n      console.log(s2.size);\n    &#x2F;&#x2F;has\n    console.log(s2.has(&#39;秀新年&#39;));\n    &#x2F;&#x2F;clear\n    \n     &#x2F;&#x2F;for of 遍歷\n    for(let v of s2)&#123;\n        console.log(v);\n    &#125;\n    \n    s2.clear();\n    console.log(s2);\n\nSet实践let arr &#x3D; [12,34,1,4123,523,65,34,1,34,523];\n        &#x2F;&#x2F;數組去重\n        let s &#x3D; [...new Set(arr)];\n        console.log(s);\n        &#x2F;&#x2F;交集\n        let arr2 &#x3D; [12, 34, 1, 423,542356346,];\n        let result &#x3D; [...new Set(arr)].filter(item &#x3D;&gt; &#123;\n            let s2 &#x3D; new Set(arr2);\n            if (s2.has(item)) &#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n        &#125;);\n        console.log(result);\n        &#x2F;&#x2F;並集\n        let union &#x3D; [...new Set([...arr, ...arr2])];\n        console.log(union);\n        &#x2F;&#x2F;差集\n        let diff &#x3D; [...new Set(arr)].filter(item &#x3D;&gt; !(new Set(arr2).has(item)));\n       console.log(diff);\n\nMapMap数据结构类似于对象 也是键值对的集合。\niterator 接口 所以可以使用 [...] 拓展运算符 和 [for...of...]进行遍历\nsize：返回元素个数\nset 添加一个新元素 返回当前的Map\nget 返回键名对象的键值\nhas 检测Map中是否包含某个元素 放回boolean值\nclear 清空集合 返回undifing \neg： \n&#x2F;&#x2F;声明 Map\n          let m &#x3D; new Map();\n          \n          &#x2F;&#x2F;添加元素\n          m.set(&#39;name&#39;,&#39;罗超越&#39;);\n          m.set(&#39;change&#39;, function() &#123;\n            console.log(&#39;五毛恶意该比啊&#39;);\n          &#125;);\n          let key &#x3D; &#123;\n            school: &#39;合肥八中&#39;\n          &#125;;\n          m.set(key,[&#39;北&#39;,&#39;南&#39;,&#39;东&#39;,&#39;西&#39;]);\n\n          &#x2F;&#x2F;size\n        console.log(m.size);\n        &#x2F;&#x2F;delete\n        m.delete(&#39;key&#39;);\n        &#x2F;&#x2F;获取get\n        console.log(m.get(key));\n        &#x2F;&#x2F;m.clear();\n        m.clear();\n        &#x2F;&#x2F;遍历\n        for(let v of m) &#123;\n            console.log(v);\n        &#125;\n        console.log(m);\n\nclass&#x2F;&#x2F;创建函数\n        &#x2F;&#x2F; function Phone (brand , price) &#123;\n        &#x2F;&#x2F;     &#x2F;&#x2F;初始化\n        &#x2F;&#x2F;     this.brand &#x3D; brand;\n        &#x2F;&#x2F;     this.price &#x3D; price;\n        &#x2F;&#x2F; &#125;;\n\n        &#x2F;&#x2F; &#x2F;&#x2F; 添加方法\n        &#x2F;&#x2F; Phone.prototype.call &#x3D; function () &#123;\n        &#x2F;&#x2F;     console.log(&#39;我可以打电话&#39;);\n        &#x2F;&#x2F; &#125;\n\n\n        &#x2F;&#x2F; &#x2F;&#x2F;实例化对象\n        &#x2F;&#x2F; let HUAWEI &#x3D; new Phone(&#39;华为&#39;, &#39;5999&#39;);\n        &#x2F;&#x2F;  HUAWEI.call();\n        &#x2F;&#x2F; console.log(HUAWEI);\n    \n       &#x2F;&#x2F;class实现\n       class Phone &#123;\n        &#x2F;&#x2F; 构造方法名字不能修改\n        constructor(brand ,price)&#123;\n            this.brand &#x3D; brand;\n            this.price &#x3D; price;\n        &#125;\n        &#x2F;&#x2F;方法必须使用该语法 ，不能使用ES5的完整形式\n        call() &#123;\n            console.log(&quot;我可以电话&quot;);\n        &#125; \n       &#125;\n       let onePlus &#x3D; new Phone(&quot;1+&quot;, 1999);\n       console.log(onePlus);\n\nclass静态成员class Phone &#123;\n      &#x2F;&#x2F;对于static 标注的属性和方法属于class类不属于实例对象\n      static name &#x3D; &#39;手机&#39;;\n      static change () &#123;\n          console.log(&quot;我可以改变世界&quot;);\n      &#125;\n     &#125;\n     let noKia &#x3D; new Phone ();\n     &#x2F;&#x2F;返回undefine\n     console.log(noKia.name);\n    console.log(Phone.name); \n\n类继承&#x2F;&#x2F;创建父类\n       class Phone &#123;\n          &#x2F;&#x2F;构造方法\n          constructor(brand, price) &#123;\n              this.brand &#x3D; brand;\n              this.price &#x3D; price;\n\n          &#125;\n          &#x2F;&#x2F; 父类的成员属性\n          call ()&#123;\n              console.log(&quot;我可以打电话&quot;);\n          &#125;\n       &#125;\n      &#x2F;&#x2F;    子类创建与 extends继承\n       class SmartPone extends Phone&#123;\n              &#x2F;&#x2F;  构造方法\n              constructor (brand, price, color, size) &#123;\n                  &#x2F;&#x2F;super继承父类   类似 Phone.call(this, brand, price)\n                  super(brand, price);  \n                  this.color &#x3D; color;\n                  this.size &#x3D; size;\n              &#125; \n              &#x2F;&#x2F;添加子类方法\n              photo () &#123;\n                  console.log(&#39;拍照&#39;);\n             &#125;\n             playGame () &#123;\n              console.log(&#39;玩游戏&#39;);\n             &#125;\n             &#x2F;&#x2F;可重写与父类同名方法，但子类不可以调用父类同名方法方法\n             call() &#123;\n              console.log(&quot;我可以进行视频通话&quot;);\n             &#125;\n       &#125;\n\n       const xiaomi &#x3D; new SmartPone(&#39;小米&#39;, 3999, &#39;红色&#39;, &#39;5.51ncr&#39;);\n       console.log(xiaomi.call());\n       console.log(xiaomi);\n\nclass 里面的get和set&#x2F;&#x2F;get 和 set\n        class Phone &#123;\n            get price () &#123;\n                console.log(&quot;价格属性被读取了&quot;);\n                return &#39;i love you&#39;;\n            &#125;\n\n            set price(NewVal) &#123;\n                console.log(&quot;价格属性被修改了&quot;);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;实例化对象\n        let s &#x3D; new Phone();\n        &#x2F;&#x2F; console.log(s.price);\n        s.price &#x3D; &#39;free&#39;;\n\n数值拓展&#x2F;&#x2F; 1.二进制和八进制\n    &#x2F;&#x2F; 2.Number.isFinite  校验一个数值是否为有限数\n    &#x2F;&#x2F;  console.log(Number.isFinite(100));\n    &#x2F;&#x2F;  console.log(number.isFinite(100&#x2F;0));\n    &#x2F;&#x2F;  console.log(number.isFinite(Infinity));\n    &#x2F;&#x2F;3.Number.isNaN用来检测数字是否为NaN\n    console.log(Number.isNaN(123));\n    \n    &#x2F;&#x2F;4. Number.parseInt Number.parFloat 字符串转整数\n    console.log(Number.parseInt(&#39;52143252love&#39;));\n    console.log(Number.parseFloat(&#39;3.1415926你好&#39;));\n    \n    &#x2F;&#x2F;5.Number.isInteger 判读一个数值是否为一个整数\n\n    console.log(Number.isInteger(5));\n    console.log(Number.isInteger(5.5));\n\n    &#x2F;&#x2F;6.Math.trunc 将数字的小数部分抹掉\n    console.log(Math.trunc(34234.5345345));\n    &#x2F;&#x2F;7.Math.sign 判断一个数到底为正数，负数，还是零\n    console.log(Math.sign(0));\n\n对象方法扩展&#x2F;&#x2F; Object.js 判断两个值是否完全相等\n    &#x2F;&#x2F; console.log(Object.is(NaN, NaN));\n    &#x2F;&#x2F;Object.assign 对象的合并\n    &#x2F;&#x2F;有相同的参数会进行覆盖\n    &#x2F;&#x2F;不同的参数添加\n    const config1 &#x3D; &#123;\n        host: &#39;localhost&#39;,\n        port: 8080,\n        name: &#39;root&#39;,\n        pass: &#39;root&#39;\n    &#125;;\n    const config2 &#x3D; &#123;\n        host: &#39;http:&#x2F;&#x2F;luohaozhe&#39;,\n        port: 3030,\n        name: &#39;luo hao zhe&#39;,\n        pass: &#39;luo@123&#39;\n    &#125;\n    console.log(Object.assign(config1, config2));\n     &#x2F;&#x2F;Object.setPrototypeOf 设置原型对象 \n    const school &#x3D; &#123;\n        name: &#39;蔡徐坤&#39;\n    &#125;\n    const cities &#x3D; &#123;\n       xiaoqu: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]\n    &#125;\n    Object.setPrototypeOf(school, cities);\n    console.log(Object.getPrototypeOf(school));\n    console.log(school);\n\n\n模块化优势：\n1.防止命名冲突\n2.代码复用\n3.高维护性\n\n暴露汇总\n1，分别暴露\nexport let job &#x3D; &#39;前端开发工程师&#39;;\n\n2.统一暴露\nlet job &#x3D; &#39;前端开发工程师&#39;;\nfunction jobs () &#123;\n    console.log(&quot;我们可以帮你找到好工作&quot;);\n&#125;\nexport &#123;job, jobs&#125;;\n\n3.默认暴露\nexport default &#123;\n    job: &#39;前端开发工程师&#39;,\n    Change: function () &#123;\n        console.log(&#39;我们可以帮助你&#39;);\n    &#125;\n&#125;\n\n引入汇总&#x2F;&#x2F;1.通用方式\n        &#x2F;&#x2F;  import * as 模块化 from &#39;.&#x2F;模块化.js&#39;;\n&#x2F;&#x2F; 2.解构赋值 引入统一暴露\n        &#x2F;&#x2F; import &#123;work, jobs&#125; from &quot;.&#x2F;模块化.js&quot;\n        &#x2F;&#x2F; console.log(work);\n        &#x2F;&#x2F; console.log(jobs());\n&#x2F;&#x2F;2.1解构赋值引入默认暴露\n        &#x2F;&#x2F; import &#123;default as m3&#125; from &quot;.&#x2F;模块化.js&quot;\n        &#x2F;&#x2F;  console.log(m3);\n           \n&#x2F;&#x2F;3 简便模式只适用于默认暴露\n        import m3 from &#39;.&#x2F;模块化.js&#39;;\n        console.log(m3);\n\nES7新特性  includes ** 幂运算includes 方法判读数组是否存在对应值  返回布尔值\neg：\nconst idor &#x3D; [&quot;蔡徐坤&quot;,&quot;王一博&quot;,&quot;肖战&quot;,&quot;陈飞宇&quot;,&quot;李易峰&quot;];\n        console.log(idor.includes(&#39;王一博&#39;));\n        console.log(idor.includes(&#39;吴亦凡&#39;));\n** 幂运算  \n        console.log(2 ** 10);  &#x2F;&#x2F;1024    \n\n\nES8 新特性async&#x2F;&#x2F;async函数  1.返回结果由return决定是一个promise对象\n   async function fn() &#123;\n          &#x2F;&#x2F;返回一个字符串\n           return &#39;蔡徐坤&#39;;\n          &#x2F;&#x2F;只要返回的结果不是一个Promise类型的对象则该函数的结果就是一个成功Promise对象\n          &#x2F;&#x2F;返回一个undifind\n          return; &#x2F;&#x2F;输出为成功的Promise\n          &#x2F;&#x2F;抛出一个错误  \n          throw new Error(&#39;出错了！！&#39;); &#x2F;&#x2F;输出为失败的Promise\n          &#x2F;&#x2F;返回一个Promise对象\n          return new Promise((resolve, reject) &#x3D;&gt; &#123;\n                resolve(&#39;成功的回调&#39;); &#x2F;&#x2F;输出一个成功的Promise对象 值为&#39;成功的回调&#39;\n                reject(&#39;失败的回调&#39;);  &#x2F;&#x2F;输出一个成功的Promise对象 值为&#39;失败的回调&#39;\n          &#125;);\n    &#125;\n    const result &#x3D; fn();\n    console.log(result);  &#x2F;&#x2F;输出一个promise对象\n     &#x2F;&#x2F;调用then方法\n    result.then(value &#x3D;&gt; &#123;\n         console.log(value);\n    &#125;,\n    reason &#x3D;&gt; &#123;\n        console.log(reason);\n    &#125;);\n\nawait1.await 必须写在async函数中\n2.wait右侧的表达式一般为Promise对象\n3.await 返回的是Promise成功的值\n4.await 的Promise失败了就会抛出异常\neg：\n    &#x2F;&#x2F;创建Promise\n        const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; resolve(&#39;成功&#39;);\n            reject(&#39;失败&#39;);\n        &#125;)\n        async function main () &#123;\n            &#x2F;&#x2F;使用 try catch捕捉错误\n            try &#123;\n                let result &#x3D; await p;\n                console.log(result);\n            &#125;catch(e)&#123;\n                  console.log(e);\n            &#125;     \n        &#125;\n        &#x2F;&#x2F;调用函数\n        main();\n\nasync和await结合读取文件案例&#x2F;&#x2F;引入fs模块\n\nconst fs &#x3D; require(&quot;fs&quot;);\n\n&#x2F;&#x2F;封装读取文件模块\n\nfunction readDgr() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;读取文件 fs.readFile() 传入 文件路径  和function (data,err)&#123;&#125;\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;大奉打更人.md&quot;, (err, data) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;如果失败\n      if (err) reject(err);\n      &#x2F;&#x2F;如果读取失败\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction readJl() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;读取文件\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;剑来.md&quot;, (err, data) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;如果失败\n      if (err) reject(err);\n      &#x2F;&#x2F; 如果成功\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction readsuiji() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;suiji.md&quot;, (err, data) &#x3D;&gt; &#123;\n      if (err) reject(err);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\n&#x2F;&#x2F;  创建async函数\nasync function main() &#123;\n  &#x2F;&#x2F; 获取打更人\n  let Dag &#x3D; await readDgr();\n  &#x2F;&#x2F;  获取剑来\n  let JL &#x3D; await readJl();\n  &#x2F;&#x2F; 获取随机\n  let Sui &#x3D; await readsuiji();\n\n  &#x2F;&#x2F; 输出\n  console.log(Dag.toString());\n  console.log(JL.toString());\n  console.log(Sui.toString());\n&#125;\nmain();\n\n\nasync+await发送Ajax请求&#x2F;&#x2F; 封装函数  发送AJAX请求  返回的结果是Promise对象\n     function sendAjax() &#123;\n       return new Promise((resolve, reject) &#x3D;&gt; &#123;\n         &#x2F;&#x2F; 定义对象\n         const x &#x3D; new XMLHttpRequest();\n         &#x2F;&#x2F; 初始化\n         x.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;imgapi.cn&#x2F;api.php?zd&#x3D;zsy&amp;fl&#x3D;&amp;gs&#x3D;json&quot;);\n         &#x2F;&#x2F;发请求\n         x.send();\n         &#x2F;&#x2F;    事件绑定\n         x.onreadystatechange &#x3D; function () &#123;\n           if (x.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n             if (x.status &gt;&#x3D; 200 &amp;&amp; x.status &lt; 300) &#123;\n               resolve(x.response);\n             &#125; else &#123;\n               reject(x.status);\n             &#125;\n           &#125;\n         &#125;;\n       &#125;);\n     &#125;\n   &#x2F;&#x2F;   测试\n   &#x2F;&#x2F; sendAjax().then(value &#x3D;&gt; &#123;\n   &#x2F;&#x2F;            console.log(value);\n   &#x2F;&#x2F; &#125;,\n   &#x2F;&#x2F; reason &#x3D;&gt; &#123;\n   &#x2F;&#x2F;       console.log(reason);\n   &#x2F;&#x2F; &#125;)\n   \n   &#x2F;&#x2F; async 和await 测试\n   async function main() &#123;\n       &#x2F;&#x2F; 发送Ajax请求\n     \n     try&#123;\n       let result &#x3D;  await sendAJAX();\n       console.log(result);\n     &#125;catch(e)&#123;\n       console.log(e);\n         \n     &#125;\n     \n   &#125;\n   main();\n\nES8对象方法拓展 &#x2F;&#x2F; 声明对象\n      const school &#x3D; &#123;\n        name: &quot;合肥八中&quot;,\n        city: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;],\n        xueke: [&quot;前端&quot;, &quot;java&quot;, &quot;大数据&quot;, &quot;运维&quot;],\n      &#125;;\n\n1.获取对象所有的键\n      console.log(Object.keys(school));\n2.获取所有的值\n      console.log(Object.values(school));\n 3.entries返回一个数据 每一个成员都是一个数组\n      &#x2F;&#x2F; 配合Map使用\n      &#x2F;&#x2F; console.log(Object.entries(school));\n      const m &#x3D; new Map(Object.entries(school));\n      console.log(m);\n4.对象属性的描述对象  getOwnPropertyDescriptors\n      consol\n\nES9新特性&#x2F;&#x2F;ES9 为对象引入了Rest参数 和 spread扩展运算符\n       function connect (&#123;host, port, ...user&#125;) &#123;\n\n        console.log(host);\n        console.log(port);\n        console.log(user);\n       &#125;\n\n       connect(&#123;\n        host: &#39;127.0.0.1&#39;,\n        port: 8080,\n        username: &#39;admin&#39;,\n        password: &#39;admin&#39;,\n        type: &#39;admin&#39;\n       &#125;);\n      &#x2F;&#x2F;扩展运算符\n      const s &#x3D; &#123;\n        q: &#39;铁砂掌&#39;\n      &#125;\n      const w &#x3D; &#123;\n        w: &#39;金钟罩&#39;\n      &#125;\n      const e &#x3D; &#123;\n        e: &#39;铁布衫&#39;\n      &#125;\n      const r &#x3D; &#123;\n        r: &#39;双节棍&#39;\n      &#125;\n      let mabaoguo &#x3D; &#123;...s, ...w, ...e, ...r&#125;;\n      console.log(mabaoguo);\n\nES9正则拓展1.正则命名分组\n \n  &#x2F;&#x2F; 声明字符串\n        &#x2F;&#x2F; let str &#x3D; &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;&#39;\n\n        &#x2F;&#x2F;之前的方法  --提取Url 和 标签文本\n\n        &#x2F;&#x2F; const reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(.*)&quot;&gt;(.*)&lt;\\&#x2F;a&gt;&#x2F;;\n\n        &#x2F;&#x2F; 执行\n        &#x2F;&#x2F; const result &#x3D; reg.exec(str);\n\n        &#x2F;&#x2F; console.log(result[1]);\n        &#x2F;&#x2F; console.log(result[2]);\n\n       &#x2F;&#x2F;方法二  \n        let str &#x3D; &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;&#39;;\n        const reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\&#x2F;a&gt;&#x2F;;\n        \n            const result &#x3D; reg.exec(str);\n            console.log(result);\n2.反向断言\n\n\n动态importbtn.onclick &#x3D; function () &#123;\n    &#x2F;&#x2F;   动态import\n    import(&#39;模块文件地址&#39;).then(module &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 调用函数\n        module.函数名();\n    &#125;)\n&#125;\n\nglobalThis始终指向全局对象","slug":"ES6/ES6","date":"2023-08-09T08:19:45.000Z","categories_index":"","tags_index":"ES6","author_index":"Luo"},{"id":"e5c9682f958fbae18070afcafeff3ba8","title":"git命令","content":"git 命令\n第一次使用git 必须设置用户信息\n\n\ngit config --global user.name luohaozhe\n\n\n设置用户邮箱 —设置成功后可以在本机找到用户目录下的.git开头文件查看\n\n\ngit config --global user.email luohaozhe@gail\n\n常看文件状态\ngit status \n当文件在本地时为红色\n当使用&#96;git add .  将目录下所有文件提交到工作区后 查看状态色为绿色\ngit add &quot;文件名&quot;  提交单个文件 将文件提交到暂存区\ngit commit -m &quot;日志&quot; &quot;文件名&quot;&#96; 可不写文件名默认提交所有文件 \nnothing to commit, working tree clean 显示没有东西需要修改\n\n查看版本信息\ngit reflog git log\n\n查看文件信息\ncat 文件名\n\n修改文件\nvim 文件名\n\nvim 基本命令\n---按insert 键进入 插入模式（Insert mode）编辑 不可删除 \n---插入模式（Insert mode）按Esc键切换到「命令行模式（command mode）可删除 \n---命令行模式（command mode 输入: 进入「Last line mode」\n---输入wq退出vim并保存输入q直接退出\n---文件修改后颜色变为红色需要再次提交到暂存区\n\n版本穿梭\ngit reflog 1.版本号信息 2.版本穿梭&#96; \ngit reset --hard &quot;版本号&quot;\n\n分支\n---查看分支\n   git branch -v\n---创建分支 \n   git branch &quot;分支名&quot; \n---切换分支 \n   git checkout 分支名\n\n合并分支\n---1.先切换到你需要合并到分支上\n---2.输入&#96;git merge &quot;分支名&quot;&#96; \n---合并冲突(两个分支上、同一文件都进行了修改git不知道用哪个、需要人为确认 )\n---解决: 打开文件 有提示 &lt;&lt;head 去、当前分支修改内容 &#x3D;&#x3D;&#x3D;&#x3D; 合并分支修改内容 HEADF&gt;&gt;&gt; \n---删除符号和相互分支上的内容。组成新的文件 \n---注意提交修改后的文件到本地库是 &#96;git commit -m “日志”&#96; 不要带文件名会报错。\n\ngithub 创建远程库\n---查看远程库别名 \n     git remote -v \n---创建远程库别名\n     git remote add &quot;别名&quot; 仓库地址\n\n本地库代码推送到远程库\ngit push 别名（没起直接放链接） 分支名\n\n本地拉取远程库\ngit pull 别名 分支\n\n克隆项目\ngit clong 项目地址\n\n邀请团队协作生成预览链接（已经npm run build 生成dist文件夹）\n1.创建gh-pages分支\n   git checkout -b gh-pages\n2.提交dist文件夹到本地库\n   git add -f dist\n3.提交dist到暂存区\n   git commit -m &#39;first commit&#39;\n4.提交dist到远程库\n   git subtree push --prefix dist origin gh-pages\n\nGit 命令清单新建 git 仓库\nsh\n\n在当前目录新建一个 Git 仓库\ngit init\n\n新建一个目录，将其初始化为 Git 仓库\ngit init [project-name]\n\n显示当前的Git配置\ngit config --list\n\n停止追踪指定文件并保留在工作区\ngit rm --cached [文件路径]\n\n删除工作区文件并且提交到暂存区\ngit rm [文件路径]\n\n代码提交提交暂存区到仓库区\ngit commit -m [提交信息]\n\n替换上一次 commit（如无代码改动，就重写上一次 commit 的提交信息）\ngit commit --amend -m [提交信息]\n\n列出所有本地分支\ngit branch\n\n列出所有远程分支\ngit branch -r\n\n列出所有本地分支和远程分支git branch -a\n\n新建一个分支，但依然停留在当前分支\ngit branch [分支名]\n\n新建一个分支，并切换到该分支\ngit checkout -b [分支名]\n\n新建一个分支，指向指定commit\ngit branch [分支名] [commit id]\n\n新建一个分支，与指定的远程分支建立追踪关系\ngit branch --track [分支名] [远程分支名]\n\n新建一个空白分支\ngit checkout --orphan [分支名]\n\n切换到指定分支，并更新工作区git checkout [分支名]\n\n切换到上一个分支\ngit checkout -\n\n合并指定分支到当前分支git merge [分支名]\n\n删除分支\ngit branch -d [分支名]\n\n删除远程分支\ngit push origin --delete [分支名]\ngit branch -dr [remote&#x2F;分支名]\n\n标签列出所有 tag\ngit tag\n\n根据当前 commit 创建一个 tag\ngit tag [tag]\n\n根据指定 commit 创建一个 tag\ngit tag [tag] [commit id]\n\n删除本地 taggit tag -d [tag]\n\n删除远程 taggit push origin :refs&#x2F;tags&#x2F;[tagName]\n\n查看 tag 信息git show [tag]\n\n提交指定 taggit push [remote] [tag]\n\n提交所有 taggit push [remote] --tags\n\n新建一个分支，指向某个taggit checkout -b [分支名] [tag]\n\n查看信息显示变更的文件git status\n\n显示当前分支的版本历史git log\n\n显示commit历史，以及每次commit发生变更的文件git log --stat\n\n搜索提交历史，根据关键词git log -S [keyword]\n\n显示某个文件的版本历史，包括文件改名git log --follow [文件路径]\ngit whatchanged [文件路径]\n\n显示指定文件相关的每一次diffgit log -p [文件路径]\n\n显示过去5次提交git log -5 --pretty --oneline\n\n显示所有提交过的用户，按提交次数排序git shortlog -sn\n\n显示指定文件是什么人在什么时间修改过git blame [file]\n\n显示暂存区和工作区的差异git diff\n\n显示工作区与当前分支最新 commit 之间的差异git diff HEAD\n\n显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;\n\n显示当前分支的最近几次提交git reflog\n\n提交sh\n\n下载远程仓库的所有变动git fetch [remote]\n\n显示所有远程仓库git remote -v\n\n显示某个远程仓库的信息git remote show [remote]\n\n增加一个新的远程仓库，并命名git remote add [name] [url]\n\n删除远程仓库git remote remove [name]\n\n查看远程仓库地址git remote get-url [name]\n\n取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]\n\n上传本地指定分支到远程仓库git push [remote] [branch]\n\n强行推送当前分支到远程仓库，即使有冲突git push [remote] --force\n\n推送所有分支到远程仓库\ngit push [remote] --all\n\n撤销sh\n\n重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变git reset [文件路径]\n\n重置暂存区与工作区，与上一次 commit 保持一致git reset --hard\n\n重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变git reset --keep [commit id]\n\n新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit id]\n\n暂存操作只暂存被追踪的文件git stash\n\n暂存所有文件并添加说明git stash [save &#39;说明信息&#39;] [-u]\n\n\n查看 stash 列表git stash list\n\n取出最近一次的 stashgit stash apply\n\n取出 stash 列表里对应数字的暂存git stash apply 数字\n\n取出并删除最近一次的 stashgit stash pop\n\n清空所有 stashgit stash clear\n\n日志查看提交过的完整日志git log\n\n查看精简日志（精简版本号和提交信息）git log --oneline\n\n查看精简日志（完整版本号和提交信息）git log --pretty&#x3D;oneline\n\n查看所有分支的所有操作记录（包括被删除的 commit 记录和 reset 操作）git reflog\n","slug":"git-1/git-1","date":"2020-09-15T10:49:36.000Z","categories_index":"","tags_index":"git","author_index":"Luo"},{"id":"3ba788290cf8ac86f241d1d02e47bb1a","title":"Javascript","content":"数组方法字符串转换1.toString() 把数组转换为数组值（逗号分隔）的字符串\neg:\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\ndocument.getElementById(&quot;demo&quot;).innerHTML &#x3D; fruits.toString(); \n\n2.join() 方法也可将所有数组元素结合为一个字符串.(用*进行分割)\neg：\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];\ndocument.getElementById(&quot;demo&quot;).innerHTML &#x3D; fruits.join(&quot; * &quot;); \n\n3.自动toString()当在在页面展示时结果与上面一致 自动转换\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];\ndocument.getElementById(&quot;demo&quot;).innerHTML &#x3D; fruits.join(&quot; * &quot;);\n\n删除数组元素1.pop() 方法从数组中删除最后一个元素：\n&#x2F;&#x2F; 从 fruits 删除最后一个元素（&quot;Mango&quot;）\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.pop();  \nconsole.log(fruits);\n\n2.shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引。\n&#x2F;&#x2F;从 fruits 删除第一个元素 &quot;Banana&quot;\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.shift();   \n\n3.delete()方法 被删除元素是一个空值empty 不建议使用\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\ndelete fruits[0];\nconsole.log(fruits);\n\n4.使用 splice() 来删除元素  splice() 在数组中不留“空洞”的情况下移除元素：\n第一个参数（0）定义新元素应该被添加（接入）的位置。\n第二个参数（1）定义应该删除多个元素。\n其余参数被省略。没有新元素将被添加。\n&#x2F;&#x2F; splice() 方法返回一个包含已删除项的数组：\n    const dynasty &#x3D; [&quot;隋朝&quot;,&quot;唐朝&quot;,&quot;宋朝&quot;,&quot;元朝&quot;,&quot;明朝&quot;,&quot;清朝&quot;];\n    &#x2F;&#x2F; dynasty.splice(2, 0, &quot;北宋&quot;, &quot;南宋&quot;);\n    &#x2F;&#x2F; console.log(dynasty);\n&#x2F;&#x2F;使用splice()删除数组\n&#x2F;&#x2F;删除第一个元素\n&#x2F;&#x2F; dynasty.splice(0, 1);\n&#x2F;&#x2F; 规律: 删除第n个元素   splice(n-1 ,n)\n&#x2F;&#x2F;删除第二个元素 \ndynasty.splice(1, 1);\nconsole.log(dynasty);\n\n\n\n添加数组元素1.push() 方法（在数组结尾处）向数组添加一个新的元素：\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.posh();  \nconsole.log(fruits);\n\n2.unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.unshift();  \nconsole.log(fruits);\n\n3. splice() 方法可用于向数组添加新项：\n第一个参数（3）定义了应添加新元素的位置（拼接）。\n\n第二个参数（0）定义应删除多少元素。\n\n其余参数（“高一”，“”）定义要添加的新元素。\n\nsplice() 方法返回一个包含已删除项的数组：\n\nconst Class&#x3D; [&quot;初一&quot;,&quot;初二&quot;,&quot;初三&quot;,&quot;高二&quot;,&quot;高三&quot;,];\nClass.splice(3, 0, &quot;高一&quot;);\nconsole.log(Class);\n\n修改数组元素1.通过索引号来修改数组的值\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits[0] &#x3D; &quot;Kiwi&quot;;  \n\n2.\n\n数组拼接1.splice() 方法可用于向数组添加新项：\n\n2.concat() 方法通过合并（连接）现有数组来创建一个新数组：\nconcat() 方法不会更改现有数组。它总是返回一个新数组。\nconcat() 方法可以使用任意数量的数组参数：\n\n合并多个数组\nconst myGirls &#x3D; [&quot;Cecilie&quot;, &quot;Lone&quot;];\nconst myBoys &#x3D; [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];\nconst myChildren &#x3D; myGirls.concat(myBoys, &#39;要连接的数组名&#39;);   &#x2F;&#x2F; 连接 myGirls 和 myBoys\n\n&#x2F;&#x2F;concat() 合并连接多个数组，中间用,分割\nconst Food &#x3D;[&quot;热干面&quot;,&quot;安徽板面&quot;,&quot;重庆小面&quot;,&quot;过桥米线&quot;,&quot;油泼面&quot;];\nconst citys &#x3D; [&quot;武汉&quot;,&quot;安徽&quot;,&quot;重庆&quot;,&quot;云南&quot;,&quot;河南&quot;];\nconst idol &#x3D; [&quot;吴亦凡&quot;,&quot;李易峰&quot;,&quot;陈飞宇&quot;,&quot;王一博&quot;,&quot;肖战&quot;];\nlet Pasta &#x3D;  Food.concat(citys, idol);\nconsole.log(Pasta);\nconcat() 方法也可以将值作为参数：\nlet Pasta &#x3D;  Food.concat([&quot;吴亦凡&quot;,&quot;李易峰&quot;,&quot;陈飞宇&quot;,&quot;王一博&quot;,&quot;肖战&quot;]);\n\n3.\n\n剪切数组1.slice() 方法用数组的某个片段切出新数组 slice()不会改变源数组的值\neg:\n从索引值1 开始剪切数组\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nconst citrus &#x3D; fruits.slice(1); \n也可以传两个参数\nslice(3,7)\n从索引值为3开始 7结束新数组不包含7的值\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nconst citrus &#x3D; fruits.slice(1, 7);\nconsole.log(citrus);\n\n\n数组排序1. sort() 方法是最强大的数组方法之一。\nsort() 方法以字母顺序对数组进行排序：\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.sort();\nconsole.log(fruits);\n\n2.reverse() 方法反转数组中的元素。 您可以使用它以降序对数组进行排序：\nconst fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.reverse();\nconsole.log(fruits);\n\n3.数字排序\n默认地，sort() 函数按照字符串顺序对值进行排序。\n\n该函数很适合字符串（&quot;Apple&quot; 会排在 &quot;Banana&quot; 之前）。\n\n不过，如果数字按照字符串来排序，则 &quot;25&quot; 大于 &quot;100&quot;，因为 &quot;2&quot; 大于 &quot;1&quot;。\n\n正因如此，sort() 方法在对数值排序时会产生不正确的结果。\n\n我们通过一个比值函数来修正此问题：\n从小到大\nconst points &#x3D; [40, 100, 1, 5, 25, 10];\npoints.sort(function(a, b)&#123;return a - b&#125;); \n\n从大到小\nconst points &#x3D; [40, 100, 1, 5, 25, 10];\npoints.sort(function(a, b)&#123;return b - a&#125;); \n\n4.比值函数 比较函数的目的是定义另一种排序顺序。\n比较函数应该返回一个负，零或正值，这取决于参数：\neg：\n当比较 40 和 100 时，sort() 方法会调用比较函数 function(40,100)。\n\n该函数计算 40-100，然后返回 -60（负值）。\n\n排序函数将把 40 排序为比 100 更低的值。\n\n5.排序对象数组\neg：\nconst cars &#x3D; [\n        &#123;type: &#39;Volvo&#39;, year: 2016&#125;,\n        &#123;type: &#39;Saab&#39;, year: 2001&#125;,\n        &#123;type: &#39;BWM&#39;, year: 2010&#125;\n     ];\n\n     displayCars();\n\n     function MyFunction () &#123;cars.sort(function (a,b) &#123;\n      return a.year - b.year\n      \n      &#125;);\n      displayCars();\n        &#125; \n     function displayCars () &#123;\n        document.getElementById(&#39;result&#39;).innerHTML &#x3D;\n        cars[0].type + &quot; &quot; + cars[0].year + &quot;&lt;br&gt;&quot; +\n        cars[1].type + &quot; &quot; + cars[1].year + &quot;&lt;br&gt;&quot; +\n        cars[2].type + &quot; &quot; + cars[2].year;\n    &#125;\n\n查找最高（或最低）的数组值1.sort（）方法\neg：\nconst point &#x3D; [1, 10, 46, 30, 79, 50, 2];\n        &#x2F;&#x2F; 升序 最小值：[0] 最大值 [length -1]\n        point.sort(function(a,b)&#123; return (a - b)&#125; );\n        document.getElementById(&#39;result&#39;).innerHTML &#x3D; point;\n        document.getElementById(&#39;max&#39;).innerHTML &#x3D; point[point.length - 1];\n        document.getElementById(&#39;min&#39;).innerHTML &#x3D; point[0];\n        \n        \nconst point &#x3D; [1, 10, 46, 30, 79, 50, 2];\n        &#x2F;&#x2F; 降序 最大值：[0] 最小值 [length -1]\n        point.sort(function(a,b)&#123; return (a - b)&#125; );\n        document.getElementById(&#39;result&#39;).innerHTML &#x3D; point;\n        document.getElementById(&#39;min&#39;).innerHTML &#x3D; point[point.length - 1];\n        document.getElementById(&#39;max&#39;).innerHTML &#x3D; point[0];\n2.使用 Math.max.apply 来查找数组中的最高值： Math.min.apply 来查找数组中的最低值：\neg：\n\n const point &#x3D; [1, 10, 46, 30, 79, 50, 2];\n        document.getElementById(&#39;demo&#39;).innerHTML &#x3D; MyArrayMax(point);\n        function MyArrayMax(arr) &#123;\n            return Math.max.apply(null, arr)\n        &#125;;\n        \n        function MyArrayMin(arr) &#123;\n            return Math.min.apply(null, arr)\n        &#125;;\n        document.getElementById(&#39;demos&#39;).innerHTML &#x3D; MyArrayMin(point);\n\n3.自制方法\n此函数遍历数组，用找到的最高值与每个值进行比较：\neg：\nconst point &#x3D; [1, 10, 46, 30, 79, 50, 2];\n       function MyArrayMax (arr) &#123;\n          let len &#x3D; arr.length\n          let max &#x3D; -Infinity;\n          while (len--) &#123;\n            if(arr[len] &gt; max) &#123;\n                max &#x3D; arr[len];\n            &#125;\n          &#125;\n          return max;\n       &#125; \n      \n       document.getElementById(&#39;demo&#39;).innerHTML &#x3D; MyArrayMax(point);   \n\n       function MyArrayMin (arr) &#123;\n          let len &#x3D; arr.length\n          let min &#x3D; Infinity;\n          while (len--) &#123;\n            if(arr[len] &lt; min) &#123;\n                min &#x3D; arr[len];\n            &#125;\n          &#125;\n          return min;\n       &#125; \n      \n       document.getElementById(&#39;demos&#39;).innerHTML &#x3D; MyArrayMin(point);   \n    \n\n数组迭代数组迭代方法对每个数组项进行操作。\n1.forEach() 方法为每个数组元素调用一次函数（回调函数）。\n：该函数接受 3 个参数：\n\n项目值\n项目索引\n数组本身\n  let txt &#x3D; &#39;&#39;;\n        const num &#x3D; [12,334,32134,4234,435,53535];\n        num.forEach(Function);\n        document.getElementById(&#39;result&#39;).innerHTML &#x3D; txt;\n        \n        function Function (value, index, array) &#123;\n                txt &#x3D; txt + value + &quot;&lt;br&gt;&quot;\n        &#125;\n\n2.Array.map()\nmap() 方法通过对每个数组元素执行函数来创建新数组。\nmap() 方法不会对没有值的数组元素执行函数。\nmap() 方法不会更改原始数组。\neg：\nconst num &#x3D; [12,334,32134,4234,435,53535];\n        let newNum &#x3D; num.map(MyFunction);\n\n       function  MyFunction (value, index, array) &#123;\n                return value * 2;\n        &#125;\n        document.getElementById(&#39;result&#39;).innerHTML &#x3D; newNum;\n\n3.Array.filter() 创建一个通过测试的元素组成的新数组\neg：\n返回值大于46547的新数组\n    const figures &#x3D; [1231,4132,41254123,23154235,235634,23554];\n    let NewFigures &#x3D; figures.filter(MyFunction);\n    function MyFunction (value, index, array) &#123;\n            return value &gt; 46547;\n    &#125;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; NewFigures;\n    \n4.Array.reduce()\nreduce() 方法在每个数组元素上运行函数，以生成（减少它）单个值。\nreduce() 方法在数组中从左到右工作。\nreduce() 方法不会减少原始数组。\n函数接受4个参数\n总数（初始值&#x2F;先前返回的值）\n项目值\n项目索引\n数组本身\neg:\n&#x2F;&#x2F;数组求和\nconst num &#x3D; [48364923,432423,4235,56346,7654,754,7547,54754,7745,754];\n    let sum &#x3D; num.reduce(MyFunction, 100);&#x2F;&#x2F;可设置初始值\n    function MyFunction (total, value, index, array)  &#123;\n           return total + value;\n    &#125;;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; sum;\n    \n5.Array.reduceRight()\nreduceRight() 方法在每个数组元素上运行函数，以生成（减少它）单个值。\nreduceRight() 方法在数组中从右到左工作。\nreduceRight() 方法不会减少原始数组。\n&#x2F;&#x2F; reduceRight() \n    &#x2F;&#x2F;数组值相加\n    const num &#x3D; [48364923,432423,4235,56346];\n    let sum &#x3D; num.reduceRight(MyFunction);\n    \n    function MyFunction (total, value, index, array) &#123;\n        return total + value;\n    &#125;;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; sum;\n\n6.Array.every()\nevery() 方法检查所有数组值是否通过测试。\neg：\n &#x2F;&#x2F;判读数组所有元素是否都大于500 返回布尔值\n    const num &#x3D; [34123,4123,423,423,53,425,345];\n    let newNum &#x3D; num.every(MyFunction);\n    function MyFunction (value, index, array) &#123;\n          return value &gt; 500\n    &#125;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; newNum;\n \n7.Array.some() some() 方法检查某些数组值是否通过了测试。 \n检查数组中是否有元素大于 500 返回布尔值\n     const num &#x3D; [3213412,423,5634,6,7,856,8967,876,9];\n     let Newnum &#x3D; num.some(MyFunction);\n     function MyFunction (value, index, array) &#123;\n        return value &gt; 90;\n\n     &#125;\n      document.getElementById(&#39;result&#39;).innerHTML &#x3D; Newnum;\n\n8.Array.indexOf()方法在数组中搜索元素值并返回其位置。\n语法\narray.indexOf(item, start)\nitem\t必需。要检索的项目。\nstart\t可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾。\n如果未找到项目，Array.indexOf() 返回 -1。\n如果项目多次出现，则返回第一次出现的位置。\neg：\nconst num &#x3D; [3213412,423,423,423,4325,34,63467547,54785];\n    let index &#x3D; num.indexOf(423);\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; index;\n\n9.Array.lastIndexOf()与indexOf()方法相似不过是从结尾开始搜索\n   const num &#x3D; [3213412,423,423,423,4925,34,63467547,54785];\n    let index &#x3D; num.lastIndexOf(423);\n\n10.Array.find() 方法返回通过测试函数的第一个数组元素的值。\n const num &#x3D; [3213412,423,234523,523,563464567547658658,568658,65];\n    let first &#x3D; num.find(MyFunction);\n    function MyFunction (value, index, array) &#123;\n        return value &gt; 4235;\n    &#125;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; first;\n    \n11. findIndex() 方法返回通过测试函数的第一个数组元素的索引\n    const num &#x3D; [3213412,423,234523,523,56346456];\n    let index &#x3D; num.findIndex(MyFunction);\n    function MyFunction (value, index, array) &#123;\n        return value &gt; 42523;\n    &#125;\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; index;\n\nJavaScript日期创建 Date 对象\nDate 对象由新的 Date() 构造函数创建。\n有 4 种方法创建新的日期对象：\nnew Date()\nnew Date(year, month, day, hours, minutes, seconds, milliseconds)\nnew Date(milliseconds)\nnew Date(date string)\n\neg:\n1. 输出当前时间\n     let d &#x3D; new Date();\n     document.getElementById(&#39;result&#39;).innerHTML &#x3D; d\n     toDateString() 方法将日期转换为更易读的格式：\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.toDateString();\n2.日期格式\n类型\t实例\nISO 日期\t&quot;2018-02-19&quot; （国际标准）\n短日期\t&quot;02&#x2F;19&#x2F;2018&quot; 或者 &quot;2018&#x2F;02&#x2F;19&quot;\n长日期\t&quot;Feb 19 2018&quot; 或者 &quot;19 Feb 2019&quot;\n完整日期\t&quot;Monday February 25 2015&quot;\n\n\n\n\n\n类型\n示例\n\n\n\nISO日期\n“2018-02-19” （国际标准）\n\n\n短日期\n“02&#x2F;19&#x2F;2018” 或者 “2018&#x2F;02&#x2F;19”\n\n\n长日期\n“Feb 19 2018” 或者 “19 Feb 2019”\n\n\n完整日期\n“Monday February 25 2015”\n\n\n日期输入格式日期获取方法\n\n\n方法\n描述\n\n\n\ngetDate()\n以数值返回天（1-31）\n\n\ngetDay()\n以数值获取周名（0-6）\n\n\ngetFullYear()\n获取四位的年（yyyy）\n\n\ngetHours()\n获取小时（0-23）\n\n\ngetMilliseconds()\n获取毫秒（0-999）\n\n\ngetMinutes()\n获取分（0-59）\n\n\ngetMonth()\n获取月（0-11）\n\n\ngetSeconds()\n获取秒（0-59）\n\n\ngetTime()\n获取时间（从 1970 年 1 月 1 日至今）\n\n\n&#x2F;&#x2F; getTime() 方法  返回毫秒数\n    let d &#x3D; new Date();\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getTime();\n\n    &#x2F;&#x2F;getFullYear() 方法  返回年\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getFullYear();\n \n    &#x2F;&#x2F;getMonth() 方法 在 JavaScript 中，第一个月（1 月）是月号 0，因此 12 月返回月号 11。\n    &#x2F;&#x2F;要获取正确的月份需要加一\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getMonth() + 1;\n   \n    &#x2F;&#x2F;getDate() 方法 以数字（1-31）返回日期的日\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getDate();\n   \n    &#x2F;&#x2F;getHours() 方法 以数字(0-23)返回日期的小时数\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getHours();\n    \n    &#x2F;&#x2F;getMinutes() 返回 （0-59）返回分钟\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getMinutes();\n    \n    &#x2F;&#x2F; getSeconds()方法 返回秒\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getSeconds();\n     \n    &#x2F;&#x2F;getMilliseconds() 方法 返回日期的毫秒数\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getMilliseconds();\n\n    &#x2F;&#x2F; getDay()方法 返回（0-6）日期的星期名\n    document.getElementById(&#39;result&#39;).innerHTML &#x3D; d.getDay();\n\n\n数据监视原理总结&lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;!-- 总结  Vue 监视数据的原理\n        1.vue会监视data中所有层次的数据\n\n\n        2.如何监测对象中的数据\n            通过setter实现监视, 且要再new Vue时就传入要监测的数据\n            (1).对象中后追加的属性,vue默认不做响应式数据\n            (2).如需给后续添加的属性做响应式请使用如下API\n            Vue.set(target, propertyName&#x2F;index , value)\n            Vue.$set(target, propertyName&#x2F;index , value)\n\n        3.如何监测数组中的数据\n             通过包裹数组更新元素的方法实现 本质就是做了两件事\n             (1)调用原生对印的方法对数组进行更新\n             (2)重新解析模板进而更新页面\n    \n        4.在Vue修改数组的某个元素一定要用如下方法\n             (1).使用这些API: push()数组末尾添加 pop() 数组末尾删除\n                 unshift()数组开头添加一个元素  shift()删除数组第一个元素\n                 splice(0,1 &#x2F;&#x2F;要截取的范围, &#39;要更换的元素&#39;)   截取数组\n                 sort() 数组排序 以上方法均会改变原数组\n                 1.1 对于 filter() 不改变源数组的方法可以将过滤后的数据赋值给源数组实现\n             (2).Vue.set(要修改的数组, &#39;要修改的值&#39;) \n                Vue.$set(要修改的数组, &#39;要修改的值&#39;) \n          特别注意:\n             Vue.set()和Vue.$set() 不能给vm 或vm的根数据对象_data 添加属性\n\n\n                  --&gt;\n\n        &lt;h2&gt;学生信息&lt;&#x2F;h2&gt;\n        &lt;br&gt;\n        &lt;button @click.once&#x3D;&quot;addSet&quot;&gt;更改朋友信息&lt;&#x2F;button&gt;\n        &lt;button @click.once&#x3D;&quot;filter&quot;&gt;过滤小蔡&lt;&#x2F;button&gt;\n         &lt;h2&gt;朋友们:&lt;&#x2F;h2&gt;\n         &lt;li v-for&#x3D;&quot;(f, index) in friend&quot;&gt;\n            &#123;&#123;f&#125;&#125;\n         &lt;&#x2F;li&gt;\n         &lt;h2&gt;偶像们&lt;&#x2F;h2&gt;\n        &lt;li v-for&#x3D;&quot;(I, index) in Idol&quot; :key&#x3D;&quot;index&quot;&gt;\n           &#123;&#123;I.name&#125;&#125; --&#123;&#123;I.age&#125;&#125;\n        &lt;&#x2F;li&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script&gt;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    student:&#123;\n                    name: &#39;小蔡&#39;,\n                    &#125;,\n                    age:&#123;\n                        rage: 40,\n                        fage: 30\n                    &#125;,\n                    friend:[&#39;jack&#39;,&#39;tony&#39;,&#39;lad&#39;, &#39;xie&#39;,&#39;chen&#39;],\n                    Idol:[\n                        &#123;name: &#39;小蔡&#39;,age: 30&#125;,\n                        &#123;name: &#39;小吴&#39;,age: 31&#125;\n                    ]\n                &#125;\n            &#125;,\n            methods: &#123;\n                addSet() &#123;&#x2F;&#x2F;要填加的数组名  索引值  value\n                &#x2F;&#x2F;    Vue.set(this.friend, &#39;0&#39;, &#39;mail&#39;) &#x2F;&#x2F;使用set修改\n                &#x2F;&#x2F; this.friend.push(&#39;mail&#39;)&#x2F;&#x2F;向数组末尾添加元素\n                &#x2F;&#x2F; this.Idol[0].name &#x3D; &#39;小李&#39; &#x2F;&#x2F;修改数组第一个元素对象的name属性\n                &#x2F;&#x2F;  this.Idol.unshift(&#123;name: &#39;小周&#39;, age:28&#125;) &#x2F;&#x2F;向数组开头添加一个元素对象\n                this.friend.splice(0,1,&#39;luo&#39;) &#x2F;&#x2F;修改数组friend中的第一个元素为luo\n            &#125;,\n            filter() &#123;\n                 this.Idol &#x3D;  this.Idol.filter((f) &#x3D;&gt; &#123;\n                   return f.name !&#x3D;&#x3D; &#39;小蔡&#39;;\n              &#125;)\n            &#125;\n            &#125;,\n        &#125;)\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n表单数据收集&lt;div id&#x3D;&quot;root&quot;&gt;\n      &lt;!-- 收集表单数据 \n      1. 普通输入框&lt;input type&#x3D;&quot;text&quot;&gt;,则v-model收集的是value,用户输入的就是value值\n      2.当选框 &lt;input type&#x3D;&quot;text&quot;&gt;则v-model收集的是value值 且要给标签配置value\n      3.多选框 &lt;input type&#x3D;&quot;checkbox&quot;&gt;\n         3.1没有配置input的value属性,那么收集的就是check (勾选 or 未勾选 是布尔值)\n         3.2配置input的value属性\n           (1)v-model的初始值是非数组,那么收集的就是check (勾选 or 未勾选 是布尔值)\n           (2)v-model的初始值是数组那么收集的就是value组成的数组\n\n           备注: v-model 的三个修饰符\n           lazy: 失去焦点在收集数据 --适用于数据较多懒加载\n           number: 将输入的含字符串的值转为纯数字 --适用于只允许含有数字的输入\n           trim: 输入框首尾空格过滤\n\n       --&gt;\n\n\n\n\n       &lt;!-- action 数据要提交的服务器地址 --&gt;\n       &lt;form action&#x3D;&quot;&quot; @submit.prevent&#x3D;&quot;demo&quot;&gt;\n        &lt;label for&#x3D;&quot;Phone&quot;&gt;账号:&lt;&#x2F;label&gt;trem\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;Phone&quot; v-model.trim&#x3D;&quot;userInfo.Phone&quot;&gt;\n         &lt;br&gt;&lt;br&gt;\n        &lt;label for&#x3D;&quot;Password&quot;&gt;密码:&lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;Password&quot; v-model&#x3D;&quot;userInfo.Password&quot;&gt;\n        \n        &lt;br&gt;&lt;br&gt;\n        &lt;label for&#x3D;&quot;age&quot;&gt;年龄:&lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;number&quot; id&#x3D;&quot;age&quot; v-model.number&#x3D;&quot;userInfo.age&quot;&gt;\n\n\n        &lt;br&gt;&lt;br&gt;\n        性别: \n        男&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;userInfo.sex&quot; value&#x3D;&quot;man&quot;&gt;\n        女&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;userInfo.sex&quot; value&#x3D;&quot;woman&quot;&gt;\n        \n        &lt;br&gt;&lt;br&gt;\n        特长：\n        唱跳 &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;userInfo.expertise&quot; value&#x3D;&quot;唱跳&quot;&gt;\n        Rap  &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;userInfo.expertise&quot; value&#x3D;&quot;Rap&quot;&gt;\n        篮球 &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;userInfo.expertise&quot; value&#x3D;&quot;篮球&quot;&gt;\n        &lt;br&gt;&lt;br&gt;\n\n       所属校区:\n       &lt;select v-model&#x3D;&quot;userInfo.city&quot;&gt;\n           &lt;option value&#x3D;&quot;&quot;&gt;请选择校区&lt;&#x2F;option&gt;\n           &lt;option value&#x3D;&quot;beijing&quot;&gt;北京&lt;&#x2F;option&gt;\n           &lt;option value&#x3D;&quot;shanghai&quot;&gt;上海&lt;&#x2F;option&gt;\n           &lt;option value&#x3D;&quot;shenzhen&quot;&gt;深圳&lt;&#x2F;option&gt;\n           &lt;option value&#x3D;&quot;wuhan&quot;&gt;武汉&lt;&#x2F;option&gt;\n       &lt;&#x2F;select&gt;\n       &lt;br&gt;&lt;br&gt;\n       其他信息：              \n       &lt;textarea cols&#x3D;&quot;30&quot; rows&#x3D;&quot;10&quot; v-model.lazy&#x3D;&quot;userInfo.other&quot;&gt;&lt;&#x2F;textarea&gt;\n        \n       &lt;br&gt;&lt;br&gt;\n      &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;userInfo.agree&quot;&gt; 阅读并接受 &lt;a href&#x3D;&quot;#&quot;&gt;《用户协议》&lt;&#x2F;a&gt;\n      &lt;br&gt;&lt;br&gt;\n      &lt;button&gt;提交&lt;&#x2F;button&gt;\n   &lt;&#x2F;form&gt;\n\n   &lt;&#x2F;div&gt;\n\n   &lt;script&gt;\n       Vue.config.productionTip &#x3D; false;\n     const vm &#x3D; new Vue(&#123;\n        data() &#123;\n           return &#123;\n               userInfo:&#123;\n               Phone: &#39;&#39;,\n               Password: &#39;&#39;,\n               age: 18,\n               sex:&#39;man&#39;,\n               expertise:[&#39;唱跳&#39;], &#x2F;&#x2F;初始值为数组\n               city:&#39;beijing&#39;,\n               other:&#39;&#39;,\n               agree:&#39;&#39;,\n               &#125;,\n               \n           &#125;\n        &#125;,\n        methods: &#123;\n           demo() &#123;&#x2F;&#x2F;将收集的数据转换成字符串输出\n              console.log(JSON.stringify(this.userInfo));\n           &#125;\n        &#125;,\n           \n           \n     &#125;) \n     vm.$mount(&#39;#root&#39;)\n   &lt;&#x2F;script&gt;\n\n过滤器&lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;!-- 过滤器:\n        定义： 对要显示的数据进行特定格式化的显示（适用于一些简单逻辑的处理）\n        语法：\n          1.注册过滤器 Vue.filter(过滤器name,function(value)&#123;&#125;)  或 new Vue (&#123;\n           filters:&#123;\n               过滤器name()&#123;\n\n               &#125;\n           &#125;\n          &#125;)\n      \n       使用过滤器：\n       &#123;&#123;要过滤的data元素 | 过滤器name&#125;&#125; 或 v-bind: &#x3D; &quot;要过滤的data元素 | 过滤器名&quot;\n        \n       备注：\n         1.过滤器也可以接收额外参数，多个过滤可串联\n         2.并没有改变原有的数据，是产生了新的相应数据 --&gt;\n\n\n       &lt;h2&gt;显示格式化后的时间&lt;&#x2F;h2&gt;\n         &lt;h3&gt;格式化前的当前时间是:&#123;&#123;Date.now()&#125;&#125;&lt;&#x2F;h3&gt;\n         &lt;!-- computed实现 --&gt;\n         &lt;h3&gt;格式化后的时间是:&#123;&#123;FormatTime&#125;&#125;&lt;&#x2F;h3&gt;\n\n         &lt;!-- methods 实现 --&gt;\n         &lt;h3&gt;现在的时间是:&#123;&#123;getFormatTime()&#125;&#125;&lt;&#x2F;h3&gt;\n\n         &lt;!-- 过滤器实现    要展示的数据 | 过滤器名(自定义)--&gt;\n         &lt;h3&gt;现在的时间是:&#123;&#123;time | timeFormat&#125;&#125;&lt;M&#x2F;h3&gt;\n\n         &lt;!-- 过滤器传参 多个过滤器串联--&gt;\n         &lt;h3&gt;现在的时间是: &#123;&#123;time | timeFormat(&#39;YYYY-MM-DD&#39;) | mySlice&#125;&#125;&lt;&#x2F;h3&gt;\n   &lt;&#x2F;div&gt;\n\n   &lt;script&gt;\n       Vue.config.productionTip &#x3D; false;\n       &#x2F;&#x2F;全局过滤器\n       &#x2F;&#x2F; Vue.filter(timeFormat,function(value) &#123;\n       &#x2F;&#x2F;     return dayjs(value).format(&#39;YYYY-MM-DD&#39;)\n       &#x2F;&#x2F; &#125;)\n       const vm &#x3D; new Vue(&#123;\n           data() &#123;\n               return &#123;\n                 time: &#39;1679060999540&#39; \n               &#125;\n           &#125;,\n           methods: &#123;\n               getFormatTime()&#123;\n                   return dayjs().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)\n               &#125;\n           &#125;,\n           computed:&#123;\n               FormatTime() &#123;\n                  return dayjs().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)\n               &#125;,\n           &#125;,\n           &#x2F;&#x2F;局部过滤器\n           filters:&#123;\n               timeFormat(value, str&#x3D;&#39;YYYY年MM月DD日 HH:mm:ss&#39;) &#123;\n                  return dayjs().format(str)\n               &#125;,\n               mySlice(value) &#123;\n                   return value.slice(0,4)\n               &#125;\n           &#125;\n       &#125;);\n       vm.$mount(&#39;#root&#39;)\n   &lt;&#x2F;script&gt;\n\n内置指令","slug":"Javascript/Javascript 基础","date":"2023-08-09T08:19:45.000Z","categories_index":"","tags_index":"Javascript","author_index":"Luo"},{"id":"5f258f833478a2a0e21ce42d19305683","title":"Vue","content":"学习Vue之前要掌握的JavaScript:基础知识？ES6语法规范&#x2F;ES6模块化\n1.默认导入与默认导出（一个文件只能使用一次默认导出）\nexport default\nimport 别名(随意符合规范) from &#39;文件地址&#39;\n2.按需导入和按需导出（一个文件可以使用多次按需导出）\nexport let a &#x3D; &#39;aaa&#39;\nexport function say() &#123;\nconsole.log(&#39;2222&#39;)\n&#125;\nimport &#123;a, say&#125; from &#39;文件地址&#39;\n3.直接导入并执行模块代码\nimport &#39;文件地址&#39;\n\n包管理器webpack\n1.在webpack的配置文件中，初始化如下基本配置：\nmodule.exports &#x3D;\nmode:&#39;development&#39;&#x2F;&#x2F;mode用来指定构建模式&#39;development开发模式编译速度快\nproduction 为生产模式压缩体积小\n\n\n2.在package,json\n配香文件中的scripts节点下，新增dev脚本如下：\n&quot;scripts&quot;:\n&quot;dev”6”webpack&quot;&#x2F;∥script节点下的脚本，可以通过npm run执行\n\n在终端中运行npm run dev命令，启动webpack进行项目打包。\n\n3.配置打包的入口与出口文件\nconst path&#x3D;require(&#39;path&#39;)&#x2F;&#x2F;导入node.js中专门操作路径的模块\nmodule.exports &#x3D;\nentry:path.join(dirname,&#39;.&#x2F;src&#x2F;index.js&#39;),&#x2F;&#x2F;打包入口文件的路径\noutput:\npath:path.join(dirname,·.&#x2F;dist&#39;),&#x2F;&#x2F;输出文件的存放路径\nfilename:&#39;bundle.js&#39;&#x2F;&#x2F;输出文件的名称\n\n技术栈\n原型、原型链\n数组常用方法\naxios\npromise\n\n数据绑定 el和data的两种写法&lt;!-- v-bind：可简写为 :\n    单向数据绑定：开发者工具数据改变页面数据变化、页面数据变化控开发者工具数据不变。 --&gt;\n   \n    &lt;!-- v-model:  v-model:value 可简写为    v-model:\n    双向数据绑定  开发者工具数据改变 页面数据也变化  页面数据变化开发者工具也变化\n    只能应用于表单类元素上（输入类元素 input 单选多选框 select框 多行输入  有 value值）其他元素类型无法使用 \n    \n--&gt;\n\n\n&lt;!-- el 和 data的两种写法\n\n\n--&gt;\n    &lt;!-- 定义容器 --&gt;\n     &lt;div id&#x3D;&quot;root&quot;&gt;\n         &lt;h1&gt;你好, &#123;&#123; name &#125;&#125;&lt;&#x2F;h1&gt;\n     &lt;&#x2F;div&gt;\n \n     &lt;script&gt;\n   Vue.config.productionTip &#x3D; false &#x2F;&#x2F;关闭生产提示\n   \n&#x2F;&#x2F;    el 第二种写法 利用$mount 属性\n&#x2F;&#x2F;    data的第二种写法\n   \n   const v &#x3D;  new Vue(&#123;\n            &#x2F;&#x2F; el:&#39;#root&#39;, &#x2F;&#x2F;el第一种写法\n            &#x2F;&#x2F; data:&#123;      &#x2F;&#x2F;data第一种写法对象式\n            &#x2F;&#x2F;  name:&#39;罗浩哲&#39;\n            &#x2F;&#x2F; &#125;\n            &#x2F;&#x2F; data第二种写法 函数式  组件必须使用\n            data() &#123;\n                console.log(&#39;@@@&#39;,this) &#x2F;&#x2F;普通函数此处的this指向Vue实例对象\n                &#x2F;&#x2F; console.log(&#39;@@@&#39;,this) &#x2F;&#x2F;不能写成箭头函数此处的this指向window全局实例对象\n\n               \n                return&#123;\n                    name: &#39;罗浩哲&#39;\n                &#125;\n            &#125;\n         &#125;);\n\n      &#x2F;&#x2F;挂载\n      v.$mount(&#39;#root&#39;)   &#x2F;&#x2F;第二种写法\n\n        &#x2F;&#x2F;  console.log(v);\n     &lt;&#x2F;script&gt;\n\nMVVM模型\ndata中的所有属性最后都出现在vm身上\nVue身上的所有属性及Vue原型上的所有属性在Vue模板上都可以直接使用\n\nObject.defineProperty 回顾 &#x2F;&#x2F;  案列age的值由number决定且当number发生改变时自动更新\n    let number &#x3D; 18\n\n    &#x2F;&#x2F;   定义对象\n    let Person &#x3D; &#123;\n        name: &#39;luo&#39;,\n        sex: &#39;男&#39;,\n    &#125;\n    &#x2F;&#x2F; 传入四个配置项 对象默认属性修改\n    &#x2F;&#x2F; Object.defineProperty(对象名, 要添加的属性名， &#123;配置对象&#125;)\n    Object.defineProperty(Person, &#39;age&#39;, &#123;\n    &#x2F;&#x2F;    value: 18,  &#x2F;&#x2F;属性值\n    &#x2F;&#x2F;    enumerable:true, &#x2F;&#x2F;控制值是否可以枚举遍历 默认值为false\n    &#x2F;&#x2F;    writable: true, &#x2F;&#x2F;控制值是否可以被修改 默认值为false\n    &#x2F;&#x2F;    configurable:true, &#x2F;&#x2F;控制值是否可以被删除 默认值为false\n\n    &#x2F;&#x2F;   当有人读取Person age 属性时 get就会被调用 且返回值就是age的值\n    get() &#123;\n        console.log(&#39;age属性被读取了&#39;);\n        return  number;\n    &#125;,\n\n    &#x2F;&#x2F;当有人修改age的属性时 set就会被调用 且会收到修改具体的值\n    set() &#123;\n        console.log(&#39;age属性被修改了 且值是&#39;, value);\n        number &#x3D; value\n    &#125;\n    \n    &#125;)\n&#x2F;&#x2F;  for(let v in Person)&#123;\n&#x2F;&#x2F;     console.log(v);\n&#x2F;&#x2F;  &#125;\n  \n&#x2F;&#x2F; console.log(Person);\n\n\n数据代理&lt;!-- 数据代理 通过一个对象代理对另一个对象中属性的操作（读&#x2F;写） --&gt;\n       \n      &lt;script&gt;\n        let Obj &#x3D; &#123;x:100&#125;\n        let Obj1 &#x3D; &#123;y:200&#125;\n        &#x2F;&#x2F; Obj1通过添加Obj中的x可以读写Obj中的值x\n       Object.defineProperty(Obj1, &#39;x&#39;, &#123;\n        get() &#123;\n            return Obj.x\n        &#125;,\n        set(value) &#123;\n            Obj.x &#x3D;  value\n        &#125;\n       &#125;)\n\n      &lt;&#x2F;script&gt;\n\n1.Vue中的数据代理\n   通过vm对象来代理data中对象中属性的操作（都getter、写、setter）\n2.Vue代理的好处\n    更加方便的操作data中的数据\n3.基本原理 ：\n    通过Object.defineProperty()把data对象中的所有属性\n    添加vm身上，为每一个添加的data中的属性都指定getter\n    和setter\n    在getter 和 setter 内部去操作（读&#x2F;写属性）data中对应的属性\n    \n\n\n事件的基本使用1.v-on:click  简写形式  @click \n2.事件的回调要写在methods中最终会出现在vm中\n3.methods中配置的函数不要用箭头函数  this\n4.methods中配置的函数 this指向vm\n5.@click&#x3D;&quot;demo&quot; 和@click&#x3D;&quot;demo($event, 要传递的参数)&quot;\n\n&lt;!-- 定义容器 --&gt;\n    &lt;div id&#x3D;&quot;root&quot;&gt;\n       &lt;h1&gt;单击事件绑定&lt;&#x2F;h1&gt;\n       &lt;!-- &lt;button v-on:click&#x3D;&quot;showInfo&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;button&gt; --&gt;\n       &lt;!-- v-on:click  简写形式  @click  传递参数  函数名后面跟)() --&gt;\n       &lt;button @click&#x3D;&quot;showInfo(99,$event)&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script&gt;\n       Vue.config.productionTip &#x3D; false;&#x2F;&#x2F;关闭生产提示\n       const vm &#x3D; new Vue(&#123;\n           data() &#123;\n               return&#123;\n                   name: &#39;luohaozhe&#39;,\n                   id: &#39;99&#39;\n               &#125;\n           &#125;,\n           methods: &#123;\n              showInfo(number,event)&#123;\n               &#x2F;&#x2F; 输出按钮中的文本\n               console.log(event.target.innerText);\n               &#x2F;&#x2F;   alert(&#39;你好吗？&#39;)\n               &#x2F;&#x2F; console.log(this);&#x2F;&#x2F;此处的this是vm\n               console.log(number);\n              &#125;\n           &#125;,\n       &#125;);\n       vm.$mount(&#39;#root&#39;);\n    &lt;&#x2F;script&gt;\n\n事件修饰符&lt;h2&gt;事件修饰符&lt;&#x2F;h2&gt;\n         &lt;!-- vue中的事件修饰符\n         1.prevent: 阻止默认事件（常用）\n         2.stop: 阻止事件冒泡  (常用)\n         3.once 事件只触发一次（常用）\n         4.capture 使用事件的捕获模式\n         5.self 只有event.target是当前操作的元素时才出发事件\n         6.passive 事件的默认行为立即执行，无需等待事件回调执行完毕\n         \n         \n         7.修饰符可以连续写\n        \n          --&gt;\n\n         &lt;!--prevent事件修饰符 阻止a标签默认跳转 --&gt;\n         &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot; @click.prevent&#x3D;&quot;showInfo&quot;&gt;点我提示信息&lt;&#x2F;a&gt;\n   \n         &lt;!-- 2.stop: 阻止事件冒泡  (常用) --&gt;\n         &lt;div id&#x3D;&quot;demo1&quot; @click&#x3D;&quot;showInfo&quot;&gt;\n            &lt;button @click.stop&#x3D;&quot;showInfo&quot;&gt;点我提示信息&lt;&#x2F;button&gt;\n         &lt;&#x2F;div&gt;\n   \n         &lt;!-- 3.once 事件只触发一次（常用） --&gt;\n         &lt;button @click.once&#x3D;&quot;showInfo&quot;&gt;点我提示内容&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false;\n       const vm &#x3D; new Vue(&#123;\n        data() &#123;\n            return &#123;\n                \n            &#125;\n        &#125;,\n        methods: &#123;\n            showInfo(e) &#123;\n                &#x2F;&#x2F;方法一 e.preventDefault() 阻止默认行为\n                &#x2F;&#x2F; e.preventDefault()\n                &#x2F;&#x2F;阻止事件冒泡\n                &#x2F;&#x2F; e.stopPropagation();\n                \n                alert(&#39;早上好呀&#39;)\n            &#125;\n        &#125;,\n       &#125;)\n       vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n键盘事件 &lt;!-- vue常用按键别名\n    1.回车  &#x3D;&#x3D; enter\n    2.删除  &#x3D;&#x3D; delete （捕获删除和退格键）\n    3.退出  &#x3D;&#x3D; esc \n    4.空格  &#x3D;&#x3D; space\n    5.换行  &#x3D;&#x3D; tab    (特殊 必须配合keydown使用)\n    上      &#x3D;&#x3D; up\n    下      &#x3D;&#x3D; down\n    左      &#x3D;&#x3D; left\n    右      &#x3D;&#x3D; right\n\n    2.Vue未提供的别名可通过  按键原始Key值去绑定 但注意要转为kebab-case（短横线命名）\n\n    3.系统修饰符（用法特殊）ctrl alt shift mate\n    （1）配合keyup使用  按下修饰键的同事，再按下其他键 随后释放其他键 事件才被触发\n      小技巧： 要指定只用按下 ctrl + y才执行    @keyup.ctrl.y\n     (2)配合keydown使用 正常触发事件\n\n     4.也可以使用keyCode去指定具体的按键（不推荐）\n    \n     5.Vue.config.KeyCodes自定义键名 &#x3D; 键码 可以订制按键别名\n\n    --&gt;\n         &lt;h2&gt;&#123;&#123;name&#125;&#125;事件&lt;&#x2F;h2&gt;\n        \n &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.enter&#x3D;&quot;showInfo&quot;&gt;\n&lt;&#x2F;div&gt;\n    &lt;script&gt;\n    Vue.config.productionTip &#x3D; false;\n       const vm &#x3D; new Vue(&#123;\n        data() &#123;\n            return &#123;\n              name: &#39;键盘&#39;  \n            &#125;\n        &#125;,\n        methods: &#123;\n            showInfo(e) &#123;\n                &#x2F;&#x2F; 按下回车时停止\n                &#x2F;&#x2F; if(e.Keycode !&#x3D;&#x3D; 13) return\n                &#x2F;&#x2F; 输出input中输入的键盘名 和键盘编码 回车为13\n                &#x2F;&#x2F; console.log( e.Key e.Keycode);\n                &#x2F;&#x2F; 输出在input中输入的值\n               console.log(e.target.value);\n            &#125;\n        &#125;,\n       &#125;)\n       vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n计算属性&lt;!-- 计算属性 computed \n     1.定义: 要用的属性不存在通过已有的属性计算出来\n     2.原理: 底层借助Object.defineproperty方法提供的getter 和setter\n        3.get函数什么时候执行\n          1.函数初次调用会执行一次\n          2.当依赖的属性发生改变时会再次被调用测试方便\n      5.备注：\n      1.计算属性最终会出现在vm上，直接读取即可\n      2.如果计算属性要被修改那必须写set函数去响应修改\n      且set中要引起计算时依赖的数据发生变化 --&gt;\n\n\n    &lt;div id&#x3D;&quot;root&quot;&gt;\n        姓: &lt;input type&#x3D;&quot;text&quot;  v-model&#x3D;&quot;surname&quot;&gt;&lt;br&gt;&lt;br&gt;\n        名:&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot;&gt;&lt;br&gt;&lt;br&gt;\n        &lt;!-- 插值语法实现 --&gt;\n        &lt;!-- &lt;h3&gt;全名: &#123;&#123;surname.slice(0,2)&#125;&#125;-&#123;&#123;name&#125;&#125;&lt;&#x2F;h3&gt; --&gt;\n        &lt;!-- methods实现 --&gt;\n        &lt;!-- &lt;h3&gt;全名: &#123;&#123;fullName()&#125;&#125;&lt;&#x2F;h3&gt; --&gt;\n        &lt;!-- 计算属性实现 --&gt;\n        &lt;h3&gt;全名: &#123;&#123;fullName&#125;&#125;&lt;&#x2F;h3&gt;\n       &lt;&#x2F;div&gt;\n\n   &lt;script&gt;\n   const vm  &#x3D; new Vue(&#123;\n       data() &#123;\n           return &#123;\n               surname: &#39;罗&#39;,\n               name: &#39;皓哲&#39;,\n           &#125;\n      \n       &#125;,\n       methods: &#123;\n       &#x2F;&#x2F;    fullName() &#123;\n       &#x2F;&#x2F;        return this.surname + &#39;-&#39; + this.name\n       &#x2F;&#x2F;    &#125;\n           &#125;,\n       computed:&#123;\n         &#x2F;&#x2F; 简写形式 ---只读取不修改才可以使用简写形式\n          fullName() &#123;\n               return this.surname + this.name\n          &#125; \n       \n       &#x2F;&#x2F;完整形式\n           fullName:&#123;\n               get() &#123;\n                &#x2F;&#x2F;get 有什么作用  当有人读取fullName()时get就会被调用\n                &#x2F;&#x2F;get 什么时候被调用  \n               &#x2F;&#x2F;   1.初次读取fullName时\n               &#x2F;&#x2F;   2.所依赖的数发生变化时\n               console.log(&#39;get被调用了&#39;);\n               &#x2F;&#x2F;this 指向 vm\n                 return this.surname + &#39;-&#39; + this.name\n               &#125;,\n               &#x2F;&#x2F;set 什么时候被调用 当fullName被修改时调用\n               set(value) &#123;\n                    console.log(&#39;set&#39;, value);\n                    &#x2F;&#x2F;按照指定字符将将数据拆分成一个数组\n                    const arr &#x3D; value.split(&#39;-&#39;)\n                    this.surname &#x3D; arr[0]\n                    this.name &#x3D; arr[1]\n               &#125;\n           &#125;\n       &#125;\n   &#125;);\n   vm.$mount(&#39;#root&#39;)\n   &lt;&#x2F;script&gt;\n\n监视属性&lt;!-- 监视属性watch\n     1.当被监视的属性发生变化时，回调函数自动调用 进行相关操作\n     2.监视的属性必须存在 才能进行监视！！！\n     3.监视的两种写法\n        (1)通过 new Vue 传入 watch:&#123;handler(NewValue,oldValue)&#123;&#125;&#125;\n        (2)通过vm.$watch(&#39;要监视的属性&#39;,&#123;配置&#125;) --&gt;\n\n\n\n    &lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;h1&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;&#x2F;h1&gt;\n     &lt;!-- &lt;button @click&#x3D;&quot;Switch&quot;&gt;切换天气&lt;&#x2F;button&gt; --&gt;\n     &lt;!-- 小技巧 语句简单可直接写到click后面--&gt;\n     &lt;button @click&#x3D;&quot;isHot &#x3D; !isHot&quot;&gt;切换天气&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n    \n     &lt;script&gt;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                   isHot: true \n                &#125;\n            &#125;,\n            computed:&#123;\n                info() &#123;\n                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;\n                &#125;\n            &#125;,\n            methods: &#123;\n                Switch() &#123;\n                   this.isHot &#x3D; !this.isHot\n                &#125;\n            &#125;,\n            watch:&#123;\n                isHot:&#123;\n\n                    immediate:true,&#x2F;&#x2F;初始化时让handler调用一下 默认为false\n                    &#x2F;&#x2F;handler 什么时候调用,当isHot被修改了\n                    handler(newValue, oldValue)&#123;\n                         console.log(&#39;isHot被修改了&#39;,newValue,oldValue);\n                    &#125;\n                &#125;,\n                &#x2F;&#x2F; info:&#123;\n                &#x2F;&#x2F;     immediate:true,&#x2F;&#x2F;初始化时让handler调用一下 默认为false\n                &#x2F;&#x2F;     &#x2F;&#x2F;handler 什么时候调用,当isHot被修改了\n                &#x2F;&#x2F;     handler(newValue, oldValue)&#123;\n                &#x2F;&#x2F;          console.log(&#39;info被修改了&#39;,newValue,oldValue);\n                &#x2F;&#x2F;     &#125;\n                &#x2F;&#x2F; &#125;\n            &#125;\n        &#125;)\n        vm.$mount(&#39;#root&#39;)\n        &#x2F;&#x2F; 监听的第二种写法\n        &#x2F;&#x2F; vm.$watch(&#39;isHot&#39;, &#123;\n        &#x2F;&#x2F;     immediate:true,&#x2F;&#x2F;初始化时让handler调用一下 默认为false\n        &#x2F;&#x2F;             &#x2F;&#x2F;handler 什么时候调用,当isHot被修改了\n        &#x2F;&#x2F;             handler(newValue, oldValue)&#123;\n        &#x2F;&#x2F;                  console.log(&#39;isHot被修改了&#39;,newValue,oldValue);\n        &#x2F;&#x2F;             &#125;\n        &#x2F;&#x2F; &#125;)\n     &lt;&#x2F;script&gt;\n\n深度监视  &lt;!-- 深度监视：\n    1.Vue的watch默认不监测对象内部值的改变\n    2.配置deep: true 可以监测对象内部值的改变\n    备注：\n    1.Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\n    2。使用watch时根据数据内部的具体结构，决定是否采用深度监视 --&gt;\n\n\n    &lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;h1&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;&#x2F;h1&gt;\n     &lt;!-- &lt;button @click&#x3D;&quot;Switch&quot;&gt;切换天气&lt;&#x2F;button&gt; --&gt;\n     &lt;!-- 小技巧 语句简单可直接写到click后面--&gt;\n     &lt;button @click&#x3D;&quot;isHot &#x3D; !isHot&quot;&gt;切换天气&lt;&#x2F;button&gt;\n     &lt;hr&gt;\n\n     &lt;h3&gt;a的值是: &#123;&#123;numbers.a&#125;&#125;&lt;&#x2F;h3&gt;\n     &lt;button @click&#x3D;&quot;numbers.a++&quot;&gt; 点我让a+1&lt;&#x2F;button&gt;\n&lt;hr&gt;\n&lt;h3&gt;b的值是: &#123;&#123;numbers.b&#125;&#125;&lt;&#x2F;h3&gt;\n     &lt;button @click&#x3D;&quot;numbers.b++&quot;&gt; 点我让b+1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    \n     &lt;script&gt;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                   isHot: true,\n                   numbers:&#123;\n                     a: 1,\n                     b: 1\n                   &#125;\n                &#125;\n            &#125;,\n            computed:&#123;\n                info() &#123;\n                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;\n                &#125;\n            &#125;,\n            methods: &#123;\n                Switch() &#123;\n                   this.isHot &#x3D; !this.isHot\n                &#125;\n            &#125;,\n            watch:&#123;\n                isHot:&#123;\n\n                    &#x2F;&#x2F; immediate:true,&#x2F;&#x2F;初始化时让handler调用一下 默认为false\n                    &#x2F;&#x2F;handler 什么时候调用,当isHot被修改了\n                    handler(newValue, oldValue)&#123;\n                         console.log(&#39;isHot被修改了&#39;,newValue,oldValue);\n                    &#125;\n                &#125;,\n                &#x2F;&#x2F;监视多级结构中某个属性值的变化\n                &#x2F;&#x2F; &#39;numbers.a&#39;:&#123;\n                &#x2F;&#x2F;     handler()&#123;\n                &#x2F;&#x2F;         console.log(&#39;a被改变了&#39;);\n                &#x2F;&#x2F;     &#125;\n                &#x2F;&#x2F; &#125;,\n                &#x2F;&#x2F;深度监视监视多级结构所有属性的变化 deep 默认为false\n\n                numbers:&#123;\n                      deep: true,\n                      handler() &#123;\n                        console.log(&#39;numbers被改变了&#39;);\n                      &#125;\n                &#125;\n            &#125;\n        &#125;)\n        vm.$mount(&#39;#root&#39;)\n\n数据监视简写&#x2F;&#x2F; 简写 只有handler时\n                 isHot(newValue, oldValue) &#123;\n                    console.log(&#39;isHot被修改了&#39;, newValue, oldValue);\n                 &#125;,\n\n\ncomputed 和 watch 的对比&lt;!-- computed 和 watch 的区别\n      1.computed能完成的,watch都可以完成\n      2.watch能完成的，computed不一定能完成 例如异步操作\n      两个重要的小原则\n      1.被vue所管理的函数最好写成普通函数  这样this指向 vm\n      2.所有不被Vue所管理的函数（定时器函数, ajax回调函数 Promise的回调函数）\n      最好写成箭头函数  这样this才会指向 vm 或组件实例对象\n       --&gt;\n\n\n\n     &lt;div id&#x3D;&quot;root&quot;&gt;\n         姓: &lt;input type&#x3D;&quot;text&quot;  v-model&#x3D;&quot;surname&quot;&gt;&lt;br&gt;&lt;br&gt;\n         名:&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot;&gt;&lt;br&gt;&lt;br&gt;\n         &lt;h3&gt;全名: &#123;&#123;fullName&#125;&#125;&lt;&#x2F;h3&gt;\n        &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n    const vm  &#x3D; new Vue(&#123;\n        data() &#123;\n            return &#123;\n               surname: &#39;罗&#39;,\n               name: &#39;浩哲&#39;,\n               fullName: &#39;罗浩哲&#39;\n            &#125;\n       \n        &#125;,\n        watch:&#123;\n            surname(val)&#123;\n                setTimeout(() &#x3D;&gt; &#123;\n                    return this.fullName &#x3D; val + &#39; &#39; + this.name;\n                &#125;, 1000);\n            &#125;,\n            name(val)&#123;\n                setTimeout(() &#x3D;&gt; &#123;\n                    return this.fullName &#x3D; this.surname + &#39; &#39; +val;\n                &#125;, 1000);\n            &#125;\n\n        &#125;\n      \n    &#125;);\n    vm.$mount(&#39;#root&#39;)\n\nclass样式绑定 style样式绑定 &lt;!-- 1.class样式绑定\n    写法： :class&#x3D;&quot;xxx&quot; xxx 可以是字符串 数组 对象\n    2.style样式绑定\n    :style&#x3D;&quot;&#123;fontSize: xxx&#125;&quot; 对象写法  其中xxx是动态值\n    :style&#x3D;&quot;[a,b]&quot; 数组形式  其中 a，b 是样式对象 --&gt;\n\n&lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;!-- 绑定class 样式----字符串写法 适用于样式类名不确定 需要动态指定 --&gt;\n     &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;mood&quot; @click&#x3D;&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n     &lt;hr&gt;\n     &lt;!-- 绑定class 样式----数组写法 适用于要绑定的样式个数不确定，名字也不确定 需要动态指定 --&gt;\n     &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;arr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n     &lt;hr&gt;\n     &lt;!-- 绑定class 样式----对象写法 适用于要绑定的样式个数确定，名字也确定 需要动态决定用不用 --&gt; \n     &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;obj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n     &lt;hr&gt;\n     \n     &lt;!-- 绑定style样式 --&gt;\n     &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;styObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script&gt;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    name: &#39;孙润美&#39;,\n                    mood: &#39;&#39;,\n                    arr: [&quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;],\n                    obj:&#123;\n                        l1: false,\n                        l2: false,\n                    &#125;,\n                    styObj:&#123;\n                        fontSize: &#39;20px&#39;,\n                        color: &#39;blue&#39;,\n                        backgroundColor: &#39;pink&#39;\n\n                    &#125;\n                &#125;\n            &#125;,\n            methods: &#123;\n                changeMood() &#123;\n                &#x2F;&#x2F; 创建数据将样式类名存入\n                 const arr &#x3D; [&#39;happy&#39;,&#39;sad&#39;,&#39;nomal&#39;];\n                &#x2F;&#x2F;  随机生成012三个数\n                const index &#x3D;   Math.floor(Math.random()*3)\n                &#x2F;&#x2F;点击随机更改颜色\n                this.mood &#x3D; arr[index]\n\n                &#125;\n            &#125;,\n        &#125;)\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n数据渲染 v-show v-if&lt;div id&#x3D;&quot;root&quot;&gt;\n      &lt;!-- 使用v-show做条件渲染  后面接布尔值或者可得到布尔值的表达式\n        底层使用 display 实现  显示与隐藏\n        变化频繁使用 v-show\n         --&gt;\n      &lt;!-- &lt;h2 v-show&#x3D;&quot;false&quot;&gt;欢迎你&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt; --&gt;\n      &lt;!-- &lt;h2 v-show&#x3D;&quot;1&#x3D;&#x3D;&#x3D;2&quot;&gt;欢迎你&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt; --&gt;\n\n      &lt;!-- 使用v-if做条件渲染  确定不再展示--&gt;\n      &lt;h2 v-if&#x3D;&quot;false&quot;&gt;欢迎你&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n\n      &lt;h2&gt;当前N的值为: &#123;&#123;n&#125;&#125;&lt;&#x2F;h2&gt;\n      &lt;button @click&#x3D;&quot;n++&quot;&gt;点我N+1&lt;&#x2F;button&gt;\n      &lt;!-- &lt;div v-show&#x3D;&quot;n&#x3D;&#x3D;&#x3D;1&quot;&gt;Angular&lt;&#x2F;div&gt;\n      &lt;div v-show&#x3D;&quot;n&#x3D;&#x3D;&#x3D;2&quot;&gt;React&lt;&#x2F;div&gt;\n      &lt;div v-show&#x3D;&quot;n&#x3D;&#x3D;&#x3D;3&quot;&gt;Vue&lt;&#x2F;div&gt; --&gt;\n\n      &lt;!-- v-else 和 v-else-if 结构不允许打断中间不能加其他元素 --&gt;\n      &lt;!-- &lt;div v-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;1&quot;&gt;Angular&lt;&#x2F;div&gt;\n      &lt;div v-else-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;2&quot;&gt;React&lt;&#x2F;div&gt;\n      &lt;div v-else-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;3&quot;&gt;Vue&lt;&#x2F;div&gt; --&gt;\n      &lt;!-- n为其他值时都显示优乐美 --&gt;\n      &lt;!-- &lt;div v-else&gt;优乐美&lt;&#x2F;div&gt; --&gt;\n\n       &lt;!-- template只能配合 v-if 使用 不能配合v-show 使用 --&gt;\n      &lt;template v-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;1 || n&#x3D;&#x3D;&#x3D;2 || n&#x3D;&#x3D;3&quot;&gt;\n        &lt;h2&gt;周一&lt;&#x2F;h2&gt;\n        &lt;h2&gt;周二&lt;&#x2F;h2&gt;\n        &lt;h2&gt;周三&lt;&#x2F;h2&gt;\n      &lt;&#x2F;template&gt;\n\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      Vue.config.productionTip &#x3D; false;\n      const vm &#x3D; new Vue(&#123;\n        data() &#123;\n          return &#123;\n            name: &quot;罗浩哲&quot;,\n            n: 0,\n          &#125;;\n        &#125;,\n      &#125;);\n      vm.$mount(&quot;#root&quot;);\n    &lt;&#x2F;script&gt;\n\n列表渲染&lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;!-- v-for 指令\n        1.用于展示列表数据\n        2.语法 v-for&#x3D;&quot;(item,index) in xxx&quot; :key&#x3D;&#39;index&#39;\n          可遍历 数组  对象  字符串 --&gt;\n      &lt;h2&gt;milk tea&lt;&#x2F;h2&gt;\n      &lt;!-- v-for in&#x2F;of 遍历数组 --&gt;\n      &lt;ul&gt;\n        &lt;!-- &lt;li v-for&#x3D;&quot;t in tea&quot; :key&#x3D;&quot;t.id&quot;&gt;&#123;&#123;t.name&#125;&#125; - &#123;&#123;t.boutique&#125;&#125;&lt;&#x2F;li&gt; --&gt;\n        &lt;!-- v-for 接收两个形参 (t, index) 可自定义 \n        t 为 数组的每一项值 , index 为数组的索引值  --&gt;\n        &lt;li v-for&#x3D;&quot;(t,index) in tea&quot; :key&#x3D;&quot;index&quot;&gt;\n          &#123;&#123;t.name&#125;&#125; - &#123;&#123;t.boutique&#125;&#125;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n\n      &lt;!-- v-for in&#x2F;of 遍历对象 --&gt;\n      &lt;h2&gt;汽车信息&lt;&#x2F;h2&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;(c,index) of car&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;index&#125;&#125; --&#123;&#123;c&#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;!-- v-for in&#x2F;of 遍历字符串 指定遍历次数 --&gt;\n    &lt;h2&gt;遍历字符串&lt;&#x2F;h2&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;(a,b) in str&quot; :key&#x3D;&quot;b&quot;&gt;&#123;&#123;a&#125;&#125; - &#123;&#123;b&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        data() &#123;\n          return &#123;\n            tea: [\n              &#123; id: &quot;001&quot;, name: &quot;蜜雪冰城&quot;, boutique: &quot;柠檬水&quot; &#125;,\n              &#123; id: &quot;002&quot;, name: &quot;一点点&quot;, boutique: &quot;珍珠奶茶&quot; &#125;,\n              &#123; id: &quot;003&quot;, name: &quot;茶百道&quot;, boutique: &quot;草莓冰沙&quot; &#125;,\n              &#123; id: &quot;004&quot;, name: &quot;古茗&quot;, boutique: &quot;百香双重奏&quot; &#125;,\n            ],\n            car: &#123;\n              name: &quot;奥迪A8&quot;,\n              price: &quot;80&quot;,\n              color: &quot;黑色&quot;,\n            &#125;,\n            str: &quot;hello&quot;,\n          &#125;;\n        &#125;,\n      &#125;);\n      vm.$mount(&quot;#root&quot;);\n    &lt;&#x2F;script&gt;\n\nv-if 中key的作用原理 —最好使用id作为key\n列表过滤 &lt;div id&#x3D;&quot;root&quot;&gt;\n        搜索：&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入搜索的信息&quot; v-model:value&#x3D;&quot;teaName&quot;&gt;&lt;br&gt;\n        &lt;ul&gt;\n            &lt;li v-for&#x3D;&quot;t in filters&quot; :key&#x3D;&quot;t.id&quot;&gt;\n                &#123;&#123;t.name&#125;&#125; - &#123;&#123;t.boutique&#125;&#125; - &#123;&#123;t.price&#125;&#125;\n            &lt;&#x2F;li&gt;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n&lt;!-- 列表过滤 --模糊搜索---watch实现 --&gt;\n    &lt;!-- &lt;script&gt;\n        \n        Vue.config.productionTip &#x3D; false;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    teaName: &#39;&#39;,\n                    tea: [\n                        &#123; id: &quot;001&quot;, name: &quot;星巴克&quot;, boutique: &quot;冰美式&quot;, price: &quot;14￥RMB&quot; &#125;,\n                        &#123; id: &quot;002&quot;, name: &quot;蜜雪冰城&quot;, boutique: &quot;柠檬水&quot;, price: &quot;4￥RMB&quot; &#125;,\n                        &#123; id: &quot;003&quot;, name: &quot;一点点&quot;, boutique: &quot;珍珠奶茶&quot;, price: &quot;19￥RMB&quot; &#125;,\n                        &#123; id: &quot;004&quot;, name: &quot;茶百道&quot;, boutique: &quot;草莓冰沙&quot;, price: &quot;19￥RMB&quot; &#125;,\n                        &#123; id: &quot;005&quot;, name: &quot;古茗&quot;, boutique: &quot;百香双重奏&quot;, price: &quot;18￥RMB&quot; &#125;,\n                    ],\n                   filter:[],\n                &#125;\n            &#125;,\n            watch: &#123;\n                teaName:&#123;\n                    immediate: true, \n                    handler(val) &#123;\n                        console.log(&#39;teaName改变了&#39;);\n                    &#x2F;&#x2F;数组过滤a\n                    this.filter &#x3D; this.tea.filter((t) &#x3D;&gt; &#123;\n                        &#x2F;&#x2F;   判断数组是否包含输入的字符 过滤生成新数组\n                        return t.name.indexOf(val) !&#x3D;&#x3D; -1\n                    &#125;)\n                &#125;\n                &#125;\n               \n            &#125;\n        &#125;);\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt; --&gt;\n&lt;!-- 列表过滤 --模糊搜索---computed实现 --&gt;  \n    &lt;script&gt;    \n        Vue.config.productionTip &#x3D; false;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    teaName:&#39;&#39;,\n                    tea: [\n                        &#123; id: &quot;001&quot;, name: &quot;星巴克&quot;, boutique: &quot;冰美式&quot;, price: &quot;14￥RMB&quot; &#125;,\n                        &#123; id: &quot;002&quot;, name: &quot;蜜雪冰城&quot;, boutique: &quot;柠檬水&quot;, price: &quot;4￥RMB&quot; &#125;,\n                        &#123; id: &quot;003&quot;, name: &quot;一点点&quot;, boutique: &quot;珍珠奶茶&quot;, price: &quot;19￥RMB&quot; &#125;,\n                        &#123; id: &quot;004&quot;, name: &quot;茶百道&quot;, boutique: &quot;草莓冰沙&quot;, price: &quot;19￥RMB&quot; &#125;,\n                        &#123; id: &quot;005&quot;, name: &quot;古茗&quot;, boutique: &quot;百香双重奏&quot;, price: &quot;18￥RMB&quot; &#125;,\n                    ],   \n                &#125;\n            &#125;,\n           computed:&#123;\n                 filters() &#123;\n                    &#x2F;&#x2F; 数组过滤  t为数组的每一项\n                    return this.tea.filter((t) &#x3D;&gt;&#123;\n                        &#x2F;&#x2F; 判断数组是否存在 输入搜索的值 即值不为-1\n                        return t.name.indexOf(this.teaName) !&#x3D;&#x3D; -1\n                    &#125;)\n                 &#125;\n           &#125;\n        &#125;);\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n\n列表排序&lt;div id&#x3D;&quot;root&quot;&gt;\n        &lt;h2&gt;奶茶列表&lt;&#x2F;h2&gt;\n        &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入店铺名&quot; v-model:value&#x3D;&quot;teaName&quot;&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 2&quot;&gt;价格升序&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 1&quot;&gt;价格降序&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 0&quot;&gt;原顺序&lt;&#x2F;button&gt;\n        &lt;ul&gt;\n            &lt;li v-for&#x3D;&quot;t in filters&quot; :key&#x3D;&quot;t.id&quot;&gt;\n                &#123;&#123;t.name&#125;&#125; - &#123;&#123;t.boutique&#125;&#125; - &#123;&#123;t.price&#125;&#125;\n            &lt;&#x2F;li&gt;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n\n&lt;!-- 列表过滤 --模糊搜索---computed实现 --&gt;  \n    &lt;script&gt;    \n        Vue.config.productionTip &#x3D; false;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    sortType: &#39;0&#39;, &#x2F;&#x2F;0为原顺序 1为降序 2为升序\n                    teaName:&#39;&#39;,\n                    tea: [\n                        &#123; id: &quot;001&quot;, name: &quot;星巴克&quot;, boutique: &quot;冰美式&quot;, price: &quot;14&quot; &#125;,\n                        &#123; id: &quot;002&quot;, name: &quot;蜜雪冰城&quot;, boutique: &quot;柠檬水&quot;, price: &quot;4&quot; &#125;,\n                        &#123; id: &quot;003&quot;, name: &quot;一点点&quot;, boutique: &quot;珍珠奶茶&quot;, price: &quot;19&quot; &#125;,\n                        &#123; id: &quot;004&quot;, name: &quot;茶百道&quot;, boutique: &quot;草莓冰沙&quot;, price: &quot;19&quot; &#125;,\n                        &#123; id: &quot;005&quot;, name: &quot;古茗&quot;, boutique: &quot;百香双重奏&quot;, price: &quot;18&quot; &#125;,\n                    ],   \n                &#125;\n            &#125;,\n           computed:&#123;\n                 filters() &#123;\n                    &#x2F;&#x2F; 数组过滤  t为数组的每一项\n                    const arr &#x3D; this.tea.filter((t) &#x3D;&gt;&#123;\n                        &#x2F;&#x2F; 判断数组是否存在 输入搜索的值 即值不为-1\n                        return t.name.indexOf(this.teaName) !&#x3D;&#x3D; -1\n                    &#125;)\n                    &#x2F;&#x2F; 判断模糊搜索过滤后的数据是否需要价格排序\n                    if(this.sortType)&#123;\n                       arr.sort((p1,p2) &#x3D;&gt; &#123;\n                         return this.sortType &#x3D;&#x3D;&#x3D; 1 ?  p1.price - p2.price : p2.price - p1.price;\n                       &#125;)  \n                    &#125;\n                    return arr\n                 &#125;\n           &#125;\n        &#125;);\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n\n内置指令&lt;!-- 内置指令  简写            描述\n             v-bind:   :             单向数据绑定\n            v-model: 省略后面的value  双向数据绑定\n              v-for                 遍历数组、对象、字符串\n              v-on     @            绑定事件监听\n              v-if                  条件渲染（动态控制节点是否存在）\n              v-else               条件渲染（动态控制节点是否存在）\n              v-show               条件渲染（动态控制节点是否展示）\n              v-test                向其所在的节点中渲染文本内容\n              v-html               向指定的节点中渲染包含html结构的内容\n             v-cloak               配合css使用可以解决网速慢时页面展示问题\n             v-once                所在节点在初次动态渲染后，就视为静态内容了\n             v-pre                 跳过其所在节点的编译过程\n            --&gt;\n            \n            &lt;!-- v-html指令\n            1.作用: 向指定的节点中渲染包含html结构的内容\n            2.与插值语法的区别\n                 2.1 v-html会替换掉节点的所有内容，&#123;&#123;xx&#125;&#125; 则不会\n                 2.2 v-html 可以识别html结构\n            3.严重注意： v-html有安全性问题！！！！\n                 3.1 在网站上动态喧嚷任意的html是非常危险的，容易导致攻击\n                 3.2 一定要在可信内容上使用v-html 永远不要用在用户提交的内容上\n\n            --&gt;\n            \n            &lt;!-- v-cloak (没有值)\n                1.本质上是一个特殊属性 Vue实例创建容器并接管以后会自动移除v-cloak属性\n                2.配合css使用可以解决网速慢时页面展示问题\n                 \n            --&gt;\n\n\n            &lt;!-- v-once 指令\n                1.v-once 所在节点在初次动态渲染后，就视为静态内容了\n                2.以后数据的改变不会引起v-once所在节点的更新 可以用于优化性能\n\n                \n            --&gt;\n    \n            &lt;!-- v-pre 指令\n               1.跳过其所在节点的编译过程\n               2.可利用它跳过没有使用指令语法没有使用插值语法的节点 会加快编译\n            \n            \n            --&gt;\n\n\n           &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;\n            &lt;!-- v-text  不支持结构解析标签里面不可以再写东西了 --&gt;\n            &lt;p v-text&#x3D;&quot;name&quot;&gt;&lt;&#x2F;p&gt;\n    \n            &lt;!-- &lt;v-html&gt;  支持结构解析 --&gt;\n            &lt;div v-html&#x3D;&quot;str&quot;&gt;&lt;&#x2F;div&gt;\n            &lt;!-- v-html 安全性问题演示 --&gt;\n            &lt;div v-html&#x3D;&quot;str2&quot;&gt;&lt;&#x2F;div&gt;\n\n            &lt;!-- v-cloak 没有值配合css使用--&gt;\n            &lt;p v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;\n            &lt;!-- &lt;style&gt;\n                [v-cloak]&#123;\n                    display: none;\n                &#125;\n            &lt;&#x2F;style&gt; --&gt;\n           \n            &lt;!-- v-once 演示 --&gt;\n            &lt;p v-once&gt;初始化的n值是: &#123;&#123;n&#125;&#125;&lt;&#x2F;p&gt;\n            &lt;p&gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;&#x2F;p&gt;\n             &lt;button @click&#x3D;&quot;n++&quot;&gt;点我N加1&lt;&#x2F;button&gt;\n\n\n\n        &lt;&#x2F;div&gt;\n    &lt;script&gt;\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                    n: 1,\n                   name: &#39;罗浩哲&#39;,\n                   str: &#39;&lt;h3&gt;你好嘢？&lt;&#x2F;h3&gt;&#39;,\n                   str2: &#39;&lt;a href&#x3D;&quot;javascript:location.href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com?+documnet.cookie&quot;&gt;诱惑性内容&lt;&#x2F;a&gt;&#39;,\n                &#125;\n            &#125;,\n        &#125;);\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n自定义指令&lt;!-- 自定义指令\n        备注：\n        1.指令定义式不加 v- 但使用时一定要加v-\n        2.指令名如果是多个单词要使用kebab-casass中间使用 - 连接 分割  定义时 要加上 &#39;&#39;\n    --&gt;\n    &lt;!-- 案例需求 \n     1.定义一个v-big 指令 和v-text功能类似 但会把绑定的数值放大10倍\n     2.定义一个v-fbind指令 和bind 指令功能类似 但会把其所绑定的input元素默认获取焦点\n    --&gt;\n\n    &lt;div id&#x3D;&quot;root&quot;&gt;\n\n      &lt;h2&gt; 当前的N值是:&lt;span v-text&#x3D;&quot;n&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h2&gt; \n      &lt;h2&gt; 放大十倍的N值是:&lt;span v-big&#x3D;&quot;n&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h2&gt; \n       &lt;button @click&#x3D;&quot;n++&quot;&gt;点我N+1&lt;&#x2F;button&gt;\n       &lt;hr&gt;\n       &lt;input type&#x3D;&quot;text&quot; v-fbind:value&#x3D;&quot;n&quot;&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false;\n        &#x2F;&#x2F;全局自定义指令\n        Vue.directive(&#39;fbind&#39;,&#123;\n            &#x2F;&#x2F;当指令与元素成功绑定时调用\n            bind(element,binding) &#123;  \n                    console.log(&#39;bind&#39;);\n                    element.value &#x3D; binding.value\n                   &#125;,\n                    &#x2F;&#x2F;指令元素被插入页面时调用\n                   inserted(element,binding)&#123;\n                    console.log(&#39;inserted&#39;); \n                      element.focus()\n                   &#125;,\n                   &#x2F;&#x2F;当指令所在模板重新解析时调用\n                   update(element,binding) &#123;\n                    console.log(&#39;update&#39;);\n                    element.value &#x3D; binding.value\n                   &#125;,\n        &#125;)\n        const vm &#x3D; new Vue(&#123;\n            data() &#123;\n                return &#123;\n                   n: 1,\n                &#125;\n            &#125;,\n            &#x2F;&#x2F;局部自定义指令\n            directives:&#123;\n                &#x2F;&#x2F;函数式写法\n                &#x2F;&#x2F; big 函数什么时候被调用  \n                &#x2F;&#x2F; 1.当指令与元素成功绑定是调用\n                &#x2F;&#x2F; 2.指令所在的模板重新解析时调用\n                big(element,binding)&#123;  \n                 console.log(element); &#x2F;&#x2F;真实DOM span标签\n                 console.log(binding); &#x2F;&#x2F;对象 value为 传入的值n\n                 element.innerText &#x3D; binding.value * 10\n                &#125;,\n\n                &#x2F;&#x2F;对象式写法\n                fbind:&#123;\n                    &#x2F;&#x2F;当指令与元素成功绑定时调用\n                   bind(element,binding) &#123;  \n                    console.log(&#39;bind&#39;);\n                    element.value &#x3D; binding.value\n                   &#125;,\n                    &#x2F;&#x2F;指令元素被插入页面时调用\n                   inserted(element,binding)&#123;\n                    console.log(&#39;inserted&#39;); \n                      element.focus()\n                   &#125;,\n                   &#x2F;&#x2F;当指令所在模板重新解析时调用\n                   update(element,binding) &#123;\n                    console.log(&#39;update&#39;);\n                    element.value &#x3D; binding.value\n                   &#125;,\n\n                &#125;\n            &#125;\n        &#125;);\n        vm.$mount(&#39;#root&#39;)\n    &lt;&#x2F;script&gt;\n\n生命周期&lt;!-- 生命周期:\n       1.又名生命周期回调函数&#x2F;生命周期函数&#x2F;生命周期钩子，\n       2.是什么:Vue在关键时期帮我们调了一些特殊名称的函数\n       3.生命周期函数的名字不可更改，但具体的函数内容根据需求编写\n       4.生命周期函数的this指向是vm或组件实例对象\n\n       常用的生命周期钩子\n       1.mounted 发送ajax请求 、启动定时器、绑定自定义事件 、订阅消息等【初始化操作】\n       2.beforeDestroy：清除定时器 、解绑自定义事件、取消订阅消息等【收尾工作】\n\n       关于销毁Vue实例\n       1.销毁后借助Vue开发者工具看不到任何信息\n       2.销毁后自定义事件会失效，但原生DOM事件依旧有效\n       3.一般不会在beforeDestroy操作数据 应为即使操作了数据也不会再更新了\n       \n   --&gt;\n\n   &lt;div id&#x3D;&quot;root&quot;&gt;\n       &lt;!-- 引出生命周期 --&gt;\n       &lt;h2 :style&#x3D;&quot;&#123;opacity&#125;&quot;&gt;Hello word&lt;&#x2F;h2&gt;\n\n       &lt;!-- 分析生命周期 --&gt;\n        &lt;h2&gt;当前的N值是:&#123;&#123;n&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;button @click&#x3D;&quot;n++&quot;&gt;点我N+1&lt;&#x2F;button&gt;\n         \n        &lt;button @click&#x3D;&quot;bye&quot;&gt;点我销毁vm&lt;&#x2F;button&gt;\n   &lt;&#x2F;div&gt;\n\n\n   &lt;script&gt;\n   Vue.config.productionTip &#x3D; false;\n   const vm &#x3D; new Vue(&#123;\n       el: &#39;#root&#39;,\n       data:&#123;\n            n: 1,\n         name: &#39;罗浩哲&#39;,\n         opacity: 1  \n       &#125;,\n       methods: &#123;\n           bye()&#123;\n               console.log(&#39;bye&#39;);\n               &#x2F;&#x2F; 销毁\n               this.$destroy()\n           &#125;\n       &#125;,\n       watch:&#123;\n          n()&#123;\n          console.log(&#39;n的值比变了&#39;);\n          &#125;\n       &#125;,\n       beforeCreate() &#123;\n           console.log(&#39;beforeCreate&#39;);\n           &#x2F;&#x2F; console.log(this)\n           &#x2F;&#x2F; debugger;&#x2F;&#x2F;断点\n       &#125;,\n       created() &#123;\n           console.log(&#39;create&#39;);\n           &#x2F;&#x2F; console.log(this)\n           &#x2F;&#x2F; debugger;&#x2F;&#x2F;断点\n       &#125;,\n       beforeMount() &#123;\n           console.log(&#39;beforeMount&#39;);\n           console.log(this)\n           debugger;&#x2F;&#x2F;断点\n       &#125;,\n       &#x2F;&#x2F;mounted（）在Vue完成模板解析并把初的真实的DOm放入页面（挂载完毕）后调用\n       mounted() &#123;\n           &#x2F;&#x2F;定时器\n          this.timer &#x3D;  setInterval(() &#x3D;&gt; &#123;\n         this.opacity -&#x3D; 0.01\n         if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n    &#125;,16) \n       &#125;,\n       beforeUpdate() &#123;\n           console.log(&#39;beforeUpdate&#39;)\n           \n       &#125;,\n      updated() &#123;\n           console.log(&#39;updated&#39;)\n      &#125;,\n      beforeDestroy() &#123;\n       &#x2F;&#x2F;   清除定时器\n      clearInterval(this.timer) \n       console.log(&#39;beforeDestroy&#39;)\n       \n      &#125;,\n      destroyed() &#123;\n       console.log(&#39;destroyed&#39;)\n       \n      &#125;,\n    &#125;)\n    \n    \n   &lt;&#x2F;script&gt;\n\n\n非单文件组件&lt;!-- Vue 中使用组件的三大步骤\n       一、创建组件（定义组件）\n          1. 如何定义\n          使用Vue.extend(options)创建其中option是和new Vue(options)\n          时传入的那么options几乎一致 两个区别\n             1.el 不要写 最终的组件毒药被一个vm所管理 由vm中的决定服务那个容器\n             2.data必须写成函数形式  ----避免组件被复用时，数据存在引用关系\n             备注： 使用template可以配置组件结构\n\n\n       二、注册组件（局部&#x2F;全局）\n          1.局部注册：靠new Vue 的时候配置 components 选项\n          2.全局注册：靠Vue.component(&#39;组件名&#39;,&#39;组件&#39;)\n\n\n       三、使用组件（通过组件标签）\n         &lt;组件名 &#x2F;&gt;\n       \n    --&gt;\n    \n    &lt;div id&#x3D;&quot;root&quot;&gt;\n         &lt;school&gt;&lt;&#x2F;school&gt;\n         &lt;hr&gt;\n         &lt;student&gt;&lt;&#x2F;student&gt;\n    &lt;&#x2F;div&gt;\n \n  \n   &lt;script&gt;\n      &#x2F;&#x2F;创建school组件\n      const school &#x3D; Vue.extend(&#123;\n         template: &#96;\n         &lt;div&gt;\n         &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n         &lt;h2&gt;学校地址： &#123;&#123;Address&#125;&#125;&lt;&#x2F;h2&gt;  \n         &lt;&#x2F;div&gt;&#96;,\n         data() &#123;\n            return &#123;\n               schoolName: &#39;合肥八中&#39;,\n               Address:&#39;安徽合肥&#39;\n            &#125;\n         &#125;,\n      &#125;)\n      \n     &#x2F;&#x2F;创建student组件\n     const student &#x3D; Vue.extend(&#123;\n      template: &#96;\n      &lt;div&gt;\n         &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;&#x2F;h2&gt;\n         &lt;h2&gt;学生年龄： &#123;&#123;age&#125;&#125;&lt;&#x2F;h2&gt;  \n      &lt;&#x2F;div&gt;\n         &#96;,\n          data() &#123;\n            return &#123;\n               studentName: &#39;罗浩哲&#39;,\n               age: 18\n            &#125;\n          &#125;,\n     &#125;)\n\n      new Vue(&#123;\n         el:&#39;#root&#39;,\n         components:&#123;\n            school,\n            student\n         &#125;\n      &#125;)\n   &lt;&#x2F;script&gt;\n\nVueComponent&lt;!-- 关于VueComponent\n        1.school: 本质上是一个名为VueComponent的构造函数，且不是程序员定义的是Vue.extend自动生成的\n\n        2.我们只需要写&lt;school&gt; Vue解析会自动帮我们创建school组件的实例对象\n            即Vue帮我们执行的 new VueComponent(options)\n\n        3.特别注意 每次调用Vue.extend 返回的都是全新的VueComponent！！！！\n\n        4.关于this的指向\n        （1）组件配置中\n             data函数 methods函数 watch函数 computed函数 中this的指向均为 VueComponent 实例对象\n\n        （2）new Vue（options）配置中\n            data函数 methods函数 watch函数 computed函数中他们的this均指向 vue实例对象\n\n        5. VueComponent的实例对象 以后简称vc 也可以称为组件实例对象\n        vue的实例对象以后简称为vm\n    \n    --&gt;\n\n    \n    &lt;div id&#x3D;&quot;root&quot;&gt;\n       &lt;school&gt;&lt;&#x2F;school&gt;\n    &lt;&#x2F;div&gt;\n \n  \n   &lt;script&gt;\n\n      &#x2F;&#x2F;创建school组件\n      const school &#x3D; Vue.extend(&#123;\n         template: &#96;\n         &lt;div&gt;\n         &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n         &lt;h2&gt;学校地址： &#123;&#123;Address&#125;&#125;&lt;&#x2F;h2&gt;  \n         \n         &lt;&#x2F;div&gt;&#96;,\n         data() &#123;\n            return &#123;\n               schoolName: &#39;合肥八中&#39;,\n               Address:&#39;安徽合肥&#39;\n            &#125;\n         &#125;,\n      &#125;)\n      \n     console.log(school);\n\n      new Vue(&#123;\n         el:&#39;#root&#39;,\n         components:&#123;\n            school\n         &#125;\n      &#125;)\n   &lt;&#x2F;script&gt;\n\n\n一个重要的内置属性Vue.Component._prototype.__proto__ &#x3D;&#x3D;&#x3D; Vue.prototype\n      为什么要有这个关系 让组件实例对象（vc）可以访问到Vue原型上的属性和方法\n\nnanoid使用1.安装\nnpm  i nanoid\n2.引入\nimport &#123;nanoid&#125; from &#39;nanoid&#39;\n3.使用\nconst personObj &#x3D; &#123;id:nanoid(),name:this.name&#125;;","slug":"Vue/Vue初始化","date":"2023-08-09T08:19:45.000Z","categories_index":"","tags_index":"Vue","author_index":"Luo"},{"id":"5f258f833478a2a0e21ce42d19305683","title":"Vue","content":"客户端与服务器服务器在上网过程中负责存放和提供资源的电脑URL组成部分\n客户端与服务器之间的通信协议\n存在该资源的服务器的名称\n资源在服务器上具体的存在位置\n\n客户端与服务器的通信过程请求——处理——响应什么是AJAX在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式\n数据交互应用场景\n用户登录注册数据的传输后台验证\n搜索提示：当输入关键字时，通过ajax的形式，动态加载搜素提示列表\n数据的分页显示：根据页码值动态的刷新表格的数据\n数据的增删改查\njQuery中的Ajax","slug":"serve/服务器","date":"2023-08-09T08:19:45.000Z","categories_index":"","tags_index":"Serve","author_index":"Luo"}]