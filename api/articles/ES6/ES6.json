{"title":"ES6","uid":"b1d4275db085b7ee39b2c5b4a055dbff","slug":"ES6/ES6","date":"2023-08-09T08:19:45.000Z","updated":"2023-08-10T01:48:38.977Z","comments":true,"path":"api/articles/ES6/ES6.json","keywords":null,"cover":"/medias/mo.jpg","content":"<h2 id=\"ES6语法\"><a href=\"#ES6语法\" class=\"headerlink\" title=\"ES6语法\"></a>ES6语法</h2><h2 id=\"let关键字\"><a href=\"#let关键字\" class=\"headerlink\" title=\"let关键字\"></a>let关键字</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">1.申明变量与赋值\neg：let a &#x3D; 100\n2.特性:不能重复申明\n3.作用域（let：块级作用域在代码块里面有效）\n4.不影响作用域链</code></pre>\n\n<h2 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">const定义常量(值不发生改变的量)\neg：const name &#x3D; &#39;luochaoyue&#39;;\n1.一定要赋初始值\n2.常量的值不能修改\n3.块级作用域\n4.对于数组和对象元素的修改不算做对常量的修改\n</code></pre>\n\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值\n数组解构\neg：\nconst F4 &#x3D; [&quot;吴亦凡&quot;, &quot;李易峰&quot;, &quot;王一博&quot;, &quot;陈飞宇&quot;];\n      let [wu, li, wang, chen] &#x3D; F4;\n      console.log(wu, li, wang, chen);\n对象解构\neg：\n&#x2F;&#x2F; 对象结构\n    const F4 &#x3D;&#123;\n        name: &#39;吴亦凡&#39;,\n        age: &#39;30&#39;,\n        music: function () &#123;\n            console.log(&#39;大碗宽面&#39;);\n        &#125;\n    &#125;;\n    let &#123;name, age, music&#125; &#x3D; F4;\n    console.log(name);\n    console.log(age);\n    console.log(music);\n    music();</code></pre>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">eg：\nlet str &#96;我是一个字符串&#96;\n1.内容中可以直接出现换行符\n2.字符串拼接\neg：\nlet iode &#x3D; &#96;肖战&#96;;\n        let msfg &#x3D; &#96;$&#123;iode&#125;是我的偶像&#96;\n        console.log(msfg);\n3.</code></pre>\n\n<h2 id=\"简化对象写法\"><a href=\"#简化对象写法\" class=\"headerlink\" title=\"简化对象写法\"></a>简化对象写法</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">let name &#x3D; &#39;蔡徐坤&#39;\n        let change &#x3D; function() &#123;\n            console.log(&#39;唱跳, RAP 篮球&#39;)\n        &#125;\n        \n        const ideo &#x3D; &#123;\n             name,\n             change,\n             imporve() &#123;\n                console.log(&#39;我们一起打篮球&#39;);\n\n             &#125;\n        &#125;\n        console.log(name, change);</code></pre>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">#eg：\n let sun &#x3D; (a,b)&#x3D;&gt; &#123;\n           return a + b;\n\n      &#125;\n      let result &#x3D; fn(1,2)\n      console.log(result);\n1.this是静态的(this始终指向函数声明时所在作用域下this的值)\n eg：\n &#x2F;&#x2F;普通函数\n    let getname &#x3D; function () &#123;\n          console.log(this.name);\n    &#125;;\n    &#x2F;&#x2F;箭头函数\n    let getname2 &#x3D; () &#x3D;&gt; &#123;\n        console.log(this.name);\n    &#125;\n    &#x2F;&#x2F; 设置window对象的name属性\n    window.name &#x3D; &#39;罗超越&#39;;\n    &#x2F;&#x2F;设置对象的name属性\n    const school &#x3D; &#123;\n        name: &#39;洛昊哲&#39;\n    &#125;\n    &#x2F;&#x2F; 直接调用\n    &#x2F;&#x2F; getname();\n    &#x2F;&#x2F; getname2();\n    &#x2F;&#x2F;  call 调用\n    getname.call(school);\n    getname2.call(school);\n  \n  2.不能作为构造函数实例化对象\n  eg：\n    let person &#x3D; (name, age) &#x3D;&gt; &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n\n    &#125; \n    let me &#x3D; new person(&#39;xaio&#39;,30);\n    console.log(me)\n    \n3.不能使用arguments变量\n\n4.箭头函数适合于this无关的回调 如定时器，数组的方法回调\n不适合与this有关的回调如 点击事件回调 对象的方法</code></pre>\n\n<h2 id=\"允许给函数参数赋值初始值\"><a href=\"#允许给函数参数赋值初始值\" class=\"headerlink\" title=\"允许给函数参数赋值初始值\"></a>允许给函数参数赋值初始值</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">let sun &#x3D; (a &#x3D; 1,b &#x3D; 2) &#x3D;&gt;&#123;\n            return a + b;\n       &#125;\n       let result &#x3D; sun();\n       console.log(result);</code></pre>\n\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">ES6 引入rest参数用函数的实参，用来代替argumnet\n &#x2F;&#x2F;返回对象\n       function date() &#123;\n       console.log(arguments);\n       &#125;\n       date(&#39;zhangbaizhi&#39;, &#39;lingzujxian&#39;, &#39;zhanaas&#39;);\n\n  &#x2F;&#x2F;返回数组  可调用数组方法\n      function date(...args)&#123;\n        console.log(args);   &#x2F;&#x2F;filte some every map \n    &#125;\n       date(&#39;冰冰&#39;,&#39;白芷&#39;,&#39;傲娇&#39;);\n       \n注意: rest参数必须放到参数的最后\n</code></pre>\n\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">[...]\nconst colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;black&#39;, &#39;pink&#39;];\n    const andomon &#x3D; [&#39;你的名字&#39;, &#39;天气之子&#39;, &#39;千与千寻&#39;, &#39;龙猫&#39;];\n    const hebin &#x3D;colors.concat(andomon);\n    console.log(hebin);\n    &#x2F;&#x2F;扩展运算符的使用 \n    &#x2F;&#x2F; 1.数组的合并\n    const hebins &#x3D; [...colors, ...andomon];\n    console.log(&#39;hebins&#39;);\n    &#x2F;&#x2F;2.数组的克隆\n    const an &#x3D; [...andomon];\n    console.log(an);\n    &#x2F;&#x2F; 将伪数组转化为真正的数组\n  const divs &#x3D; document.querySelectorAll(&#39;div&#39;)\n  console.log(divs);\n  const divss &#x3D; [...divs];\n  console.log(divss);</code></pre>\n\n<h2 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">ES6引入的一种新的原始数据类型 表示独一无二的值\n创建\nlet s1 &#x3D; Symbol();\n1.值是唯一的---用来解决命名冲突的问题\n2.值不能与其他数据进行运算\n3.定义的对象属性不能用for....in遍历循环但可以使用Reflect.ownKEys\n来获取对象的所用键名\n\n &#x2F;&#x2F;创建函数\n        let s1 &#x3D; Symbol();\n        console.log(s1, typeof s1);\n        let s2 &#x3D; Symbol(&#39;罗超越&#39;);\n        let s3 &#x3D; Symbol(&#39;罗超越&#39;);\n       console.log(s2 &#x3D;&#x3D;&#x3D; s3);\n       &#x2F;&#x2F;创建对象\n       let s4 &#x3D; Symbol.for(&#39;罗超越&#39;)\n       let s5 &#x3D; Symbol.for(&#39;罗超越&#39;)\n\n       console.log(s4 &#x3D;&#x3D;&#x3D; s5);\n4.使用(向对象添加属性和方法)\neg：\n let youxi &#x3D; &#123;\n        name: &#39;狼人杀&#39;,\n        [Symbol(&#39;say&#39;)]: function () &#123;\n            console.log(&#39;我可以说话&#39;);\n        &#125;,\n        [Symbol(&#39;zibao&#39;)]: function() &#123;\n            console.log(&#39;我可以自爆&#39;);\n        &#125;\n      &#125;\n        console.log(youxi);\n5.Symbol内置值\nclass person&#123;\n   satatic[Symbol.hasInstance()&#123;\n   console.log(&#39;我被用来检测类型了&#39;)];2\n&#125;</code></pre>\n\n<h2 id=\"数据类型-记忆\"><a href=\"#数据类型-记忆\" class=\"headerlink\" title=\"数据类型(记忆)\"></a>数据类型(记忆)</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">USONB   you are so niubility\nU  undefined\nS  string Symbol\nO 　object\nN　number\nB boolean\n</code></pre>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">（Iterator）是一种接口,为不同的数据结构提供统一的访问机制\n\n任何数据结构只要部署iterator接口(对象里面的一个属性)，就可以完成遍历操作\n1.新的遍历命令 for ...of 循环\n原生具备iterator接口的数据可使用for....of(遍历)\nArray\nArguments\nSet\nMap\nString\nTypedArray\nNodeLIst</code></pre>\n\n<h2 id=\"自定义遍历数据\"><a href=\"#自定义遍历数据\" class=\"headerlink\" title=\"自定义遍历数据\"></a>自定义遍历数据</h2><h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;模拟数据 用户数据 &#x3D;&gt; 订单数据 &#x3D;&gt;商品数据 依次一秒后输出\n        function getUser() &#123;\n             setTimeout(()&#x3D;&gt; &#123;\n                let data &#x3D; &#39;用户数据&#39;;\n                &#x2F;&#x2F;调用next() 方法并将data传入\n                iterator.next(data);\n             &#125; ,1000);\n        &#125;\n\n        function getOrder() &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                let data  &#x3D; &#39;订单数据&#39;;\n                iterator.next(data);\n            &#125;, 1000);\n        &#125;\n\n        function getGoods() &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                let data &#x3D; &#39;商品数据&#39;;\n                iterator.next(data);\n            &#125;, 1000);\n        &#125;\n\n        function * gen () &#123;\n          let user &#x3D; yield getUser();\n          console.log(user);\n          let order &#x3D;  yield getOrder();\n          console.log(order);\n           let goos &#x3D; yield getGoods()\n           console.log(goos);\n        &#125;\n\n        &#x2F;&#x2F; 调用生成器函数\n        let iterator &#x3D; gen();\n        iterator.next();  &#x2F;&#x2F;运行第一段代码\n</code></pre>\n\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">Promise是ES6引入的异步编程的新解决方案\n语法上它是一个构造函数\n用来封装异步操作并可以获取其成功或失败的结果\neg：\n let myPromise &#x3D; new Promise(function(myResolve, myReject) &#123;\n&#x2F;&#x2F; &quot;Producing Code&quot;（可能需要一些时间）\n    setTimeout(() &#x3D;&gt; &#123;\n    let data &#x3D; &#39;数据库中的用户数据&#39;;  \n    &#x2F;&#x2F; console.log(data); \n    myResolve(data);\n    &#125;, 1000);\n    setTimeout(() &#x3D;&gt; &#123;\n    let err &#x3D; &#39;数据出错了&#39;;\n    &#x2F;&#x2F; console.log(err);\n    myReject(err);\n    &#125;,1000);\n&#125;);\n\n&#x2F;&#x2F; &quot;Consuming Code&quot; （必须等待一个兑现的承诺）\nmyPromise.then(\n  function(value) &#123; console.log(value);&#125;,\n  function(error) &#123; console.log(error);&#125;\n);\n\n2.读取文件\neg：\n&#x2F;&#x2F;引入fs规则\nconst fs &#x3D; require(&#39;fs&#39;);\n\n&#x2F;&#x2F;调用方法读取文件\nfs.readFile(&#39;.&#x2F;resuorces&#x2F;suiji.md&#39;,(err,data) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;如果失败则抛出错误\n    if(err) throw err;\n    &#x2F;&#x2F;如果没有出错则输出这个内容\n    console.log(data.toString());\n&#125;);\n</code></pre>\n\n<h2 id=\"使用Promise封装AJAX请求\"><a href=\"#使用Promise封装AJAX请求\" class=\"headerlink\" title=\"使用Promise封装AJAX请求\"></a>使用Promise封装AJAX请求</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F; 使用Promise封装AJAx请求\n        &#x2F;&#x2F;创建promise对象\n        const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n        \n             &#x2F;&#x2F; 创建对象AJAX请求对象\n        const xhr &#x3D; new XMLHttpRequest();\n        &#x2F;&#x2F;初始化\n        xhr.open(&quot;GET&quot;, &#39;https:&#x2F;&#x2F;api.apiopen&#x2F;getJoke&#39;);\n        &#x2F;&#x2F;发请求\n        xhr.send();\n        &#x2F;&#x2F;绑定事件 回调函数\n        xhr.onreadystatechange &#x3D; function() &#123;\n            if(xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n                if(xhr.status  &gt;&#x3D; 200 &amp;&amp; xhr.status &gt; 300)&#123;\n                    resolve(xhr.response);\n                &#125;else&#123;\n                    reject(xhr.status);\n                &#125;\n            &#125;\n        &#125;       \n        &#125;); \n        &#x2F;&#x2F; 指定成功失败的回调\n        p.then(function(value)&#123;\n            console.log(value);\n        &#125;,function(reason)&#123;\n            console.error(reason);\n        &#125;);</code></pre>\n\n<h2 id=\"Promise-prototype-then方法\"><a href=\"#Promise-prototype-then方法\" class=\"headerlink\" title=\"Promise.prototype.then方法\"></a>Promise.prototype.then方法</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F; 创建Promise对象\n        const P &#x3D; new Promise ((resolve, reject) &#x3D;&gt; &#123;\n            setTimeout(() &#x3D;&gt; &#123;\n                &#x2F;&#x2F;成功的数据\n                resolve(&#39;成功的数据&#39;);\n                \n            &#125;,1000);\n            setTimeout(() &#x3D;&gt; &#123;\n               &#x2F;&#x2F;失败的数据\n               reject(&#39;失败的数据&#39;);\n            &#125;,2000)\n        &#125;);\n           &#x2F;&#x2F;通过p.then()方法处理回调\n        &#x2F;&#x2F;    P.then(function(value) &#123;\n        &#x2F;&#x2F;          console.log(value);\n        &#x2F;&#x2F;    &#125;,function(reason) &#123;\n        &#x2F;&#x2F;          console.error(reason);\n        &#x2F;&#x2F;    &#125;);\n        &#x2F;&#x2F;   1. p.then() 的返回结果也是一个Promise 他的状态结果由回调函数里面执行结果决定\n        &#x2F;&#x2F;   2.如果回调函数中返回的结果 为非Promise类型的属性， 状态为成功 放回值为对象中成功的值\n        &#x2F;&#x2F;   3.抛出错误 状态也为reject 值为抛出错误里面的值\n        &#x2F;&#x2F;   所以Promise是可以链式调用的\n        &#x2F;&#x2F; const result &#x3D; P.then(value &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     console.log(value);\n        &#x2F;&#x2F;     &#x2F;&#x2F;2.非Promise的情况\n        &#x2F;&#x2F;     &#x2F;&#x2F; return &#39;i love you&#39;\n        &#x2F;&#x2F;     &#x2F;&#x2F;返回的值是一个Promise值\n        &#x2F;&#x2F;     &#x2F;&#x2F; return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     &#x2F;&#x2F;     resolve(&#39;ok&#39;); &#x2F;&#x2F;决定外面Promise的状态为resolve 值为ok\n        &#x2F;&#x2F;     &#x2F;&#x2F; &#125;);\n        &#x2F;&#x2F;     &#x2F;&#x2F; 3.抛出错误\n        &#x2F;&#x2F;     &#x2F;&#x2F; throw new Error(&#39;出错啦!!!&#39;)\n\n        &#x2F;&#x2F; &#125;, reason &#x3D;&gt; &#123;\n        &#x2F;&#x2F;     console.error(reason);\n        &#x2F;&#x2F; &#125;);\n\n\n        &#x2F;&#x2F; 链式调用 失败回调可省略\n        p.then(value &#x3D;&gt; &#123;\n\n        &#125;).then(value &#x3D;&gt; &#123;\n\n        &#125;);\n        console.log(result);</code></pre>\n\n<h2 id=\"promise-链式调用\"><a href=\"#promise-链式调用\" class=\"headerlink\" title=\"promise 链式调用\"></a>promise 链式调用</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;基础方法  实现多个文件读取合并输出\n&#x2F;&#x2F;    fs.readFile(&#39;.&#x2F;resuorces&#x2F;剑来.md&#39;, (err, data1) &#x3D;&gt; &#123;\n&#x2F;&#x2F;       fs.readFile(&#39;.&#x2F;resuorces&#x2F;烽火戏诸侯.md&#39;, (err, data2) &#x3D;&gt; &#123;\n&#x2F;&#x2F;          fs.readFile(&#39;.&#x2F;resuorces&#x2F;大奉打更人.md&#39;, (err, data3) &#x3D;&gt; &#123;\n&#x2F;&#x2F;             let result &#x3D; data1 + &#39;\\r\\n&#39; + data2 +&#39;\\r\\n&#39; + data3;\n&#x2F;&#x2F;              console.log(result);\n&#x2F;&#x2F;           &#125;);\n&#x2F;&#x2F;       &#125;);\n&#x2F;&#x2F;  &#125;);\n\n&#x2F;&#x2F;使用 promise 实现\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n   fs.readFile(&quot;.&#x2F;resuorces&#x2F;剑来.md&quot;, (err, data) &#x3D;&gt; &#123;\n      resolve(data);\n   &#125;);\n&#125;);\n\np.then(value &#x3D;&gt; &#123;\n   return new Promise((resolve,reject) &#x3D;&gt; &#123;\n\n \n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;大奉打更人.md&quot;, (err,data) &#x3D;&gt; &#123;\n        resolve([value, data]);\n        \n    &#125;);\n&#x2F;&#x2F;    console.log(value.toString());\n&#125;);\n&#125;).then(value &#x3D;&gt; &#123;\n   return new Promise((resolve,reject) &#x3D;&gt; &#123;\n\n  \n   fs.readFile(&quot;.&#x2F;resuorces&#x2F;烽火戏诸侯.md&quot;,(err,data) &#x3D;&gt; &#123;\n      value.push(data);\n      resolve(value);\n   &#125;)\n&#125;);\n&#125;).then(value &#x3D;&gt; &#123;\n   console.log(value.join(&#39;\\r\\n&#39;));\n&#125;)\n</code></pre>\n\n<h2 id=\"promise-catch-方法\"><a href=\"#promise-catch-方法\" class=\"headerlink\" title=\"promise catch() 方法\"></a>promise catch() 方法</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">const p  &#x3D; new  Promise((resolve, reject) &#x3D;&gt; &#123;\n            &#x2F;&#x2F;定时器\n            setTimeout(() &#x3D;&gt; &#123;\n                &#x2F;&#x2F;设置p对象的状态为失败 并设置失败的值\n                 reject(&#39;出错啦！！！&#39;);\n            &#125;, 1000);\n        &#125;);\n        &#x2F;&#x2F;p.then()方法\n        p.then(value &#x3D;&gt; &#123;\n\n        &#125;, reason &#x3D;&gt; &#123;\n            console.error(reason);\n        &#125;);\n\n        &#x2F;&#x2F; p.catch() 方法\n        p.catch(function(reason)&#123;\n            console.warn(reason);\n        &#125;)</code></pre>\n\n<h2 id=\"Set-数据结构\"><a href=\"#Set-数据结构\" class=\"headerlink\" title=\"Set 数据结构\"></a>Set 数据结构</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">set(集合)它类似于数组，但成员的值都是唯一的\n实现了iteration 可使用扩展运算符[...] 和 for of 遍历\n1.size  返回结合的元素个数\n2.add 增加一个新元素 返回当前集合\n3.delete 删除元素 返回boolean值\n4.has 检测集合中是否包含某个元素  返回boolean值\n5.clear 清空内容\neg：\n &lt;!-- 声明一个Set()  --&gt;\n    &lt;script&gt;\n      let s &#x3D; new Set();\n      &#x2F;&#x2F;参数 --可迭代数据 --一般为数组 不可重複 自動去重\n      let s2 &#x3D; new Set([&quot;秀倩&quot;, &quot;杨千幻&quot;, &quot;秀新年&quot;, &quot;秀倩&quot;]);\n      &#x2F;&#x2F;添加集合元素\n      s2.add(&#39;威亞是你&#39;);\n      &#x2F;&#x2F;刪除元素\n       s2.delete(&#39;秀倩&#39;);\n    \n     \n      console.log(s, typeof s);\n      console.log(s2);\n      &#x2F;&#x2F;元素個數\n      console.log(s2.size);\n    &#x2F;&#x2F;has\n    console.log(s2.has(&#39;秀新年&#39;));\n    &#x2F;&#x2F;clear\n    \n     &#x2F;&#x2F;for of 遍歷\n    for(let v of s2)&#123;\n        console.log(v);\n    &#125;\n    \n    s2.clear();\n    console.log(s2);</code></pre>\n\n<h2 id=\"Set实践\"><a href=\"#Set实践\" class=\"headerlink\" title=\"Set实践\"></a>Set实践</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">let arr &#x3D; [12,34,1,4123,523,65,34,1,34,523];\n        &#x2F;&#x2F;數組去重\n        let s &#x3D; [...new Set(arr)];\n        console.log(s);\n        &#x2F;&#x2F;交集\n        let arr2 &#x3D; [12, 34, 1, 423,542356346,];\n        let result &#x3D; [...new Set(arr)].filter(item &#x3D;&gt; &#123;\n            let s2 &#x3D; new Set(arr2);\n            if (s2.has(item)) &#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n        &#125;);\n        console.log(result);\n        &#x2F;&#x2F;並集\n        let union &#x3D; [...new Set([...arr, ...arr2])];\n        console.log(union);\n        &#x2F;&#x2F;差集\n        let diff &#x3D; [...new Set(arr)].filter(item &#x3D;&gt; !(new Set(arr2).has(item)));\n       console.log(diff);</code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">Map数据结构类似于对象 也是键值对的集合。\niterator 接口 所以可以使用 [...] 拓展运算符 和 [for...of...]进行遍历\nsize：返回元素个数\nset 添加一个新元素 返回当前的Map\nget 返回键名对象的键值\nhas 检测Map中是否包含某个元素 放回boolean值\nclear 清空集合 返回undifing \neg： \n&#x2F;&#x2F;声明 Map\n          let m &#x3D; new Map();\n          \n          &#x2F;&#x2F;添加元素\n          m.set(&#39;name&#39;,&#39;罗超越&#39;);\n          m.set(&#39;change&#39;, function() &#123;\n            console.log(&#39;五毛恶意该比啊&#39;);\n          &#125;);\n          let key &#x3D; &#123;\n            school: &#39;合肥八中&#39;\n          &#125;;\n          m.set(key,[&#39;北&#39;,&#39;南&#39;,&#39;东&#39;,&#39;西&#39;]);\n\n          &#x2F;&#x2F;size\n        console.log(m.size);\n        &#x2F;&#x2F;delete\n        m.delete(&#39;key&#39;);\n        &#x2F;&#x2F;获取get\n        console.log(m.get(key));\n        &#x2F;&#x2F;m.clear();\n        m.clear();\n        &#x2F;&#x2F;遍历\n        for(let v of m) &#123;\n            console.log(v);\n        &#125;\n        console.log(m);</code></pre>\n\n<h2 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;创建函数\n        &#x2F;&#x2F; function Phone (brand , price) &#123;\n        &#x2F;&#x2F;     &#x2F;&#x2F;初始化\n        &#x2F;&#x2F;     this.brand &#x3D; brand;\n        &#x2F;&#x2F;     this.price &#x3D; price;\n        &#x2F;&#x2F; &#125;;\n\n        &#x2F;&#x2F; &#x2F;&#x2F; 添加方法\n        &#x2F;&#x2F; Phone.prototype.call &#x3D; function () &#123;\n        &#x2F;&#x2F;     console.log(&#39;我可以打电话&#39;);\n        &#x2F;&#x2F; &#125;\n\n\n        &#x2F;&#x2F; &#x2F;&#x2F;实例化对象\n        &#x2F;&#x2F; let HUAWEI &#x3D; new Phone(&#39;华为&#39;, &#39;5999&#39;);\n        &#x2F;&#x2F;  HUAWEI.call();\n        &#x2F;&#x2F; console.log(HUAWEI);\n    \n       &#x2F;&#x2F;class实现\n       class Phone &#123;\n        &#x2F;&#x2F; 构造方法名字不能修改\n        constructor(brand ,price)&#123;\n            this.brand &#x3D; brand;\n            this.price &#x3D; price;\n        &#125;\n        &#x2F;&#x2F;方法必须使用该语法 ，不能使用ES5的完整形式\n        call() &#123;\n            console.log(&quot;我可以电话&quot;);\n        &#125; \n       &#125;\n       let onePlus &#x3D; new Phone(&quot;1+&quot;, 1999);\n       console.log(onePlus);</code></pre>\n\n<h2 id=\"class静态成员\"><a href=\"#class静态成员\" class=\"headerlink\" title=\"class静态成员\"></a>class静态成员</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">class Phone &#123;\n      &#x2F;&#x2F;对于static 标注的属性和方法属于class类不属于实例对象\n      static name &#x3D; &#39;手机&#39;;\n      static change () &#123;\n          console.log(&quot;我可以改变世界&quot;);\n      &#125;\n     &#125;\n     let noKia &#x3D; new Phone ();\n     &#x2F;&#x2F;返回undefine\n     console.log(noKia.name);\n    console.log(Phone.name); </code></pre>\n\n<h2 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;创建父类\n       class Phone &#123;\n          &#x2F;&#x2F;构造方法\n          constructor(brand, price) &#123;\n              this.brand &#x3D; brand;\n              this.price &#x3D; price;\n\n          &#125;\n          &#x2F;&#x2F; 父类的成员属性\n          call ()&#123;\n              console.log(&quot;我可以打电话&quot;);\n          &#125;\n       &#125;\n      &#x2F;&#x2F;    子类创建与 extends继承\n       class SmartPone extends Phone&#123;\n              &#x2F;&#x2F;  构造方法\n              constructor (brand, price, color, size) &#123;\n                  &#x2F;&#x2F;super继承父类   类似 Phone.call(this, brand, price)\n                  super(brand, price);  \n                  this.color &#x3D; color;\n                  this.size &#x3D; size;\n              &#125; \n              &#x2F;&#x2F;添加子类方法\n              photo () &#123;\n                  console.log(&#39;拍照&#39;);\n             &#125;\n             playGame () &#123;\n              console.log(&#39;玩游戏&#39;);\n             &#125;\n             &#x2F;&#x2F;可重写与父类同名方法，但子类不可以调用父类同名方法方法\n             call() &#123;\n              console.log(&quot;我可以进行视频通话&quot;);\n             &#125;\n       &#125;\n\n       const xiaomi &#x3D; new SmartPone(&#39;小米&#39;, 3999, &#39;红色&#39;, &#39;5.51ncr&#39;);\n       console.log(xiaomi.call());\n       console.log(xiaomi);</code></pre>\n\n<h2 id=\"class-里面的get和set\"><a href=\"#class-里面的get和set\" class=\"headerlink\" title=\"class 里面的get和set\"></a>class 里面的get和set</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;get 和 set\n        class Phone &#123;\n            get price () &#123;\n                console.log(&quot;价格属性被读取了&quot;);\n                return &#39;i love you&#39;;\n            &#125;\n\n            set price(NewVal) &#123;\n                console.log(&quot;价格属性被修改了&quot;);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;实例化对象\n        let s &#x3D; new Phone();\n        &#x2F;&#x2F; console.log(s.price);\n        s.price &#x3D; &#39;free&#39;;</code></pre>\n\n<h2 id=\"数值拓展\"><a href=\"#数值拓展\" class=\"headerlink\" title=\"数值拓展\"></a>数值拓展</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F; 1.二进制和八进制\n    &#x2F;&#x2F; 2.Number.isFinite  校验一个数值是否为有限数\n    &#x2F;&#x2F;  console.log(Number.isFinite(100));\n    &#x2F;&#x2F;  console.log(number.isFinite(100&#x2F;0));\n    &#x2F;&#x2F;  console.log(number.isFinite(Infinity));\n    &#x2F;&#x2F;3.Number.isNaN用来检测数字是否为NaN\n    console.log(Number.isNaN(123));\n    \n    &#x2F;&#x2F;4. Number.parseInt Number.parFloat 字符串转整数\n    console.log(Number.parseInt(&#39;52143252love&#39;));\n    console.log(Number.parseFloat(&#39;3.1415926你好&#39;));\n    \n    &#x2F;&#x2F;5.Number.isInteger 判读一个数值是否为一个整数\n\n    console.log(Number.isInteger(5));\n    console.log(Number.isInteger(5.5));\n\n    &#x2F;&#x2F;6.Math.trunc 将数字的小数部分抹掉\n    console.log(Math.trunc(34234.5345345));\n    &#x2F;&#x2F;7.Math.sign 判断一个数到底为正数，负数，还是零\n    console.log(Math.sign(0));</code></pre>\n\n<h2 id=\"对象方法扩展\"><a href=\"#对象方法扩展\" class=\"headerlink\" title=\"对象方法扩展\"></a>对象方法扩展</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F; Object.js 判断两个值是否完全相等\n    &#x2F;&#x2F; console.log(Object.is(NaN, NaN));\n    &#x2F;&#x2F;Object.assign 对象的合并\n    &#x2F;&#x2F;有相同的参数会进行覆盖\n    &#x2F;&#x2F;不同的参数添加\n    const config1 &#x3D; &#123;\n        host: &#39;localhost&#39;,\n        port: 8080,\n        name: &#39;root&#39;,\n        pass: &#39;root&#39;\n    &#125;;\n    const config2 &#x3D; &#123;\n        host: &#39;http:&#x2F;&#x2F;luohaozhe&#39;,\n        port: 3030,\n        name: &#39;luo hao zhe&#39;,\n        pass: &#39;luo@123&#39;\n    &#125;\n    console.log(Object.assign(config1, config2));\n     &#x2F;&#x2F;Object.setPrototypeOf 设置原型对象 \n    const school &#x3D; &#123;\n        name: &#39;蔡徐坤&#39;\n    &#125;\n    const cities &#x3D; &#123;\n       xiaoqu: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]\n    &#125;\n    Object.setPrototypeOf(school, cities);\n    console.log(Object.getPrototypeOf(school));\n    console.log(school);\n</code></pre>\n\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">优势：\n1.防止命名冲突\n2.代码复用\n3.高维护性</code></pre>\n\n<h2 id=\"暴露汇总\"><a href=\"#暴露汇总\" class=\"headerlink\" title=\"暴露汇总\"></a>暴露汇总</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">\n1，分别暴露\nexport let job &#x3D; &#39;前端开发工程师&#39;;\n\n2.统一暴露\nlet job &#x3D; &#39;前端开发工程师&#39;;\nfunction jobs () &#123;\n    console.log(&quot;我们可以帮你找到好工作&quot;);\n&#125;\nexport &#123;job, jobs&#125;;\n\n3.默认暴露\nexport default &#123;\n    job: &#39;前端开发工程师&#39;,\n    Change: function () &#123;\n        console.log(&#39;我们可以帮助你&#39;);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"引入汇总\"><a href=\"#引入汇总\" class=\"headerlink\" title=\"引入汇总\"></a>引入汇总</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;1.通用方式\n        &#x2F;&#x2F;  import * as 模块化 from &#39;.&#x2F;模块化.js&#39;;\n&#x2F;&#x2F; 2.解构赋值 引入统一暴露\n        &#x2F;&#x2F; import &#123;work, jobs&#125; from &quot;.&#x2F;模块化.js&quot;\n        &#x2F;&#x2F; console.log(work);\n        &#x2F;&#x2F; console.log(jobs());\n&#x2F;&#x2F;2.1解构赋值引入默认暴露\n        &#x2F;&#x2F; import &#123;default as m3&#125; from &quot;.&#x2F;模块化.js&quot;\n        &#x2F;&#x2F;  console.log(m3);\n           \n&#x2F;&#x2F;3 简便模式只适用于默认暴露\n        import m3 from &#39;.&#x2F;模块化.js&#39;;\n        console.log(m3);</code></pre>\n\n<h2 id=\"ES7新特性-includes-幂运算\"><a href=\"#ES7新特性-includes-幂运算\" class=\"headerlink\" title=\"ES7新特性  includes ** 幂运算\"></a>ES7新特性  includes ** 幂运算</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">includes 方法判读数组是否存在对应值  返回布尔值\neg：\nconst idor &#x3D; [&quot;蔡徐坤&quot;,&quot;王一博&quot;,&quot;肖战&quot;,&quot;陈飞宇&quot;,&quot;李易峰&quot;];\n        console.log(idor.includes(&#39;王一博&#39;));\n        console.log(idor.includes(&#39;吴亦凡&#39;));\n** 幂运算  \n        console.log(2 ** 10);  &#x2F;&#x2F;1024    \n</code></pre>\n\n<h2 id=\"ES8-新特性\"><a href=\"#ES8-新特性\" class=\"headerlink\" title=\"ES8 新特性\"></a>ES8 新特性</h2><h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;async函数  1.返回结果由return决定是一个promise对象\n   async function fn() &#123;\n          &#x2F;&#x2F;返回一个字符串\n           return &#39;蔡徐坤&#39;;\n          &#x2F;&#x2F;只要返回的结果不是一个Promise类型的对象则该函数的结果就是一个成功Promise对象\n          &#x2F;&#x2F;返回一个undifind\n          return; &#x2F;&#x2F;输出为成功的Promise\n          &#x2F;&#x2F;抛出一个错误  \n          throw new Error(&#39;出错了！！&#39;); &#x2F;&#x2F;输出为失败的Promise\n          &#x2F;&#x2F;返回一个Promise对象\n          return new Promise((resolve, reject) &#x3D;&gt; &#123;\n                resolve(&#39;成功的回调&#39;); &#x2F;&#x2F;输出一个成功的Promise对象 值为&#39;成功的回调&#39;\n                reject(&#39;失败的回调&#39;);  &#x2F;&#x2F;输出一个成功的Promise对象 值为&#39;失败的回调&#39;\n          &#125;);\n    &#125;\n    const result &#x3D; fn();\n    console.log(result);  &#x2F;&#x2F;输出一个promise对象\n     &#x2F;&#x2F;调用then方法\n    result.then(value &#x3D;&gt; &#123;\n         console.log(value);\n    &#125;,\n    reason &#x3D;&gt; &#123;\n        console.log(reason);\n    &#125;);</code></pre>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">1.await 必须写在async函数中\n2.wait右侧的表达式一般为Promise对象\n3.await 返回的是Promise成功的值\n4.await 的Promise失败了就会抛出异常\neg：\n    &#x2F;&#x2F;创建Promise\n        const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; resolve(&#39;成功&#39;);\n            reject(&#39;失败&#39;);\n        &#125;)\n        async function main () &#123;\n            &#x2F;&#x2F;使用 try catch捕捉错误\n            try &#123;\n                let result &#x3D; await p;\n                console.log(result);\n            &#125;catch(e)&#123;\n                  console.log(e);\n            &#125;     \n        &#125;\n        &#x2F;&#x2F;调用函数\n        main();</code></pre>\n\n<h2 id=\"async和await结合读取文件案例\"><a href=\"#async和await结合读取文件案例\" class=\"headerlink\" title=\"async和await结合读取文件案例\"></a>async和await结合读取文件案例</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;引入fs模块\n\nconst fs &#x3D; require(&quot;fs&quot;);\n\n&#x2F;&#x2F;封装读取文件模块\n\nfunction readDgr() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;读取文件 fs.readFile() 传入 文件路径  和function (data,err)&#123;&#125;\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;大奉打更人.md&quot;, (err, data) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;如果失败\n      if (err) reject(err);\n      &#x2F;&#x2F;如果读取失败\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction readJl() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;读取文件\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;剑来.md&quot;, (err, data) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;如果失败\n      if (err) reject(err);\n      &#x2F;&#x2F; 如果成功\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction readsuiji() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    fs.readFile(&quot;.&#x2F;resuorces&#x2F;suiji.md&quot;, (err, data) &#x3D;&gt; &#123;\n      if (err) reject(err);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;\n\n&#x2F;&#x2F;  创建async函数\nasync function main() &#123;\n  &#x2F;&#x2F; 获取打更人\n  let Dag &#x3D; await readDgr();\n  &#x2F;&#x2F;  获取剑来\n  let JL &#x3D; await readJl();\n  &#x2F;&#x2F; 获取随机\n  let Sui &#x3D; await readsuiji();\n\n  &#x2F;&#x2F; 输出\n  console.log(Dag.toString());\n  console.log(JL.toString());\n  console.log(Sui.toString());\n&#125;\nmain();\n</code></pre>\n\n<h2 id=\"async-await发送Ajax请求\"><a href=\"#async-await发送Ajax请求\" class=\"headerlink\" title=\"async+await发送Ajax请求\"></a>async+await发送Ajax请求</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F; 封装函数  发送AJAX请求  返回的结果是Promise对象\n     function sendAjax() &#123;\n       return new Promise((resolve, reject) &#x3D;&gt; &#123;\n         &#x2F;&#x2F; 定义对象\n         const x &#x3D; new XMLHttpRequest();\n         &#x2F;&#x2F; 初始化\n         x.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;imgapi.cn&#x2F;api.php?zd&#x3D;zsy&amp;fl&#x3D;&amp;gs&#x3D;json&quot;);\n         &#x2F;&#x2F;发请求\n         x.send();\n         &#x2F;&#x2F;    事件绑定\n         x.onreadystatechange &#x3D; function () &#123;\n           if (x.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n             if (x.status &gt;&#x3D; 200 &amp;&amp; x.status &lt; 300) &#123;\n               resolve(x.response);\n             &#125; else &#123;\n               reject(x.status);\n             &#125;\n           &#125;\n         &#125;;\n       &#125;);\n     &#125;\n   &#x2F;&#x2F;   测试\n   &#x2F;&#x2F; sendAjax().then(value &#x3D;&gt; &#123;\n   &#x2F;&#x2F;            console.log(value);\n   &#x2F;&#x2F; &#125;,\n   &#x2F;&#x2F; reason &#x3D;&gt; &#123;\n   &#x2F;&#x2F;       console.log(reason);\n   &#x2F;&#x2F; &#125;)\n   \n   &#x2F;&#x2F; async 和await 测试\n   async function main() &#123;\n       &#x2F;&#x2F; 发送Ajax请求\n     \n     try&#123;\n       let result &#x3D;  await sendAJAX();\n       console.log(result);\n     &#125;catch(e)&#123;\n       console.log(e);\n         \n     &#125;\n     \n   &#125;\n   main();</code></pre>\n\n<h2 id=\"ES8对象方法拓展\"><a href=\"#ES8对象方法拓展\" class=\"headerlink\" title=\"ES8对象方法拓展\"></a>ES8对象方法拓展</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\"> &#x2F;&#x2F; 声明对象\n      const school &#x3D; &#123;\n        name: &quot;合肥八中&quot;,\n        city: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;],\n        xueke: [&quot;前端&quot;, &quot;java&quot;, &quot;大数据&quot;, &quot;运维&quot;],\n      &#125;;\n\n1.获取对象所有的键\n      console.log(Object.keys(school));\n2.获取所有的值\n      console.log(Object.values(school));\n 3.entries返回一个数据 每一个成员都是一个数组\n      &#x2F;&#x2F; 配合Map使用\n      &#x2F;&#x2F; console.log(Object.entries(school));\n      const m &#x3D; new Map(Object.entries(school));\n      console.log(m);\n4.对象属性的描述对象  getOwnPropertyDescriptors\n      consol</code></pre>\n\n<h2 id=\"ES9新特性\"><a href=\"#ES9新特性\" class=\"headerlink\" title=\"ES9新特性\"></a>ES9新特性</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">&#x2F;&#x2F;ES9 为对象引入了Rest参数 和 spread扩展运算符\n       function connect (&#123;host, port, ...user&#125;) &#123;\n\n        console.log(host);\n        console.log(port);\n        console.log(user);\n       &#125;\n\n       connect(&#123;\n        host: &#39;127.0.0.1&#39;,\n        port: 8080,\n        username: &#39;admin&#39;,\n        password: &#39;admin&#39;,\n        type: &#39;admin&#39;\n       &#125;);\n      &#x2F;&#x2F;扩展运算符\n      const s &#x3D; &#123;\n        q: &#39;铁砂掌&#39;\n      &#125;\n      const w &#x3D; &#123;\n        w: &#39;金钟罩&#39;\n      &#125;\n      const e &#x3D; &#123;\n        e: &#39;铁布衫&#39;\n      &#125;\n      const r &#x3D; &#123;\n        r: &#39;双节棍&#39;\n      &#125;\n      let mabaoguo &#x3D; &#123;...s, ...w, ...e, ...r&#125;;\n      console.log(mabaoguo);</code></pre>\n\n<h2 id=\"ES9正则拓展\"><a href=\"#ES9正则拓展\" class=\"headerlink\" title=\"ES9正则拓展\"></a>ES9正则拓展</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">1.正则命名分组\n \n  &#x2F;&#x2F; 声明字符串\n        &#x2F;&#x2F; let str &#x3D; &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;&#39;\n\n        &#x2F;&#x2F;之前的方法  --提取Url 和 标签文本\n\n        &#x2F;&#x2F; const reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(.*)&quot;&gt;(.*)&lt;\\&#x2F;a&gt;&#x2F;;\n\n        &#x2F;&#x2F; 执行\n        &#x2F;&#x2F; const result &#x3D; reg.exec(str);\n\n        &#x2F;&#x2F; console.log(result[1]);\n        &#x2F;&#x2F; console.log(result[2]);\n\n       &#x2F;&#x2F;方法二  \n        let str &#x3D; &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;&#39;;\n        const reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\&#x2F;a&gt;&#x2F;;\n        \n            const result &#x3D; reg.exec(str);\n            console.log(result);\n2.反向断言\n</code></pre>\n\n<h2 id=\"动态import\"><a href=\"#动态import\" class=\"headerlink\" title=\"动态import\"></a>动态import</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">btn.onclick &#x3D; function () &#123;\n    &#x2F;&#x2F;   动态import\n    import(&#39;模块文件地址&#39;).then(module &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 调用函数\n        module.函数名();\n    &#125;)\n&#125;</code></pre>\n\n<h2 id=\"globalThis\"><a href=\"#globalThis\" class=\"headerlink\" title=\"globalThis\"></a>globalThis</h2><pre class=\"line-numbers language-bush\" data-language=\"bush\"><code class=\"language-bush\">始终指向全局对象</code></pre>","text":"ES6语法let关键字1.申明变量与赋值 eg：let a &#x3D; 100 2.特性:不能重复申明 3.作用域（let：块级作用域在代码块里面有效） 4.不影响作用域链 const 关键字const定义常量(值不发生改变的量) eg：const name &#x3D; &#...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[],"tags":[{"name":"ES6","slug":"ES6","count":1,"path":"api/tags/ES6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">ES6语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#let%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">let关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#const-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">const 关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">解构赋值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">模板字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95\"><span class=\"toc-text\">简化对象写法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%81%E8%AE%B8%E7%BB%99%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">允许给函数参数赋值初始值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rest%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">rest参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">扩展运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#symbol\"><span class=\"toc-text\">symbol</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%AE%B0%E5%BF%86\"><span class=\"toc-text\">数据类型(记忆)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">自定义遍历数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">生成器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85AJAX%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">使用Promise封装AJAX请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise-prototype-then%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Promise.prototype.then方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#promise-%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">promise 链式调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#promise-catch-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">promise catch() 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Set 数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">Set实践</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class\"><span class=\"toc-text\">class</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">class静态成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-%E9%87%8C%E9%9D%A2%E7%9A%84get%E5%92%8Cset\"><span class=\"toc-text\">class 里面的get和set</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">数值拓展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">对象方法扩展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">模块化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9A%B4%E9%9C%B2%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">暴露汇总</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">引入汇总</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES7%E6%96%B0%E7%89%B9%E6%80%A7-includes-%E5%B9%82%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">ES7新特性  includes ** 幂运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES8-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ES8 新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async\"><span class=\"toc-text\">async</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#await\"><span class=\"toc-text\">await</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async%E5%92%8Cawait%E7%BB%93%E5%90%88%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">async和await结合读取文件案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-await%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">async+await发送Ajax请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">ES8对象方法拓展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES9%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ES9新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES9%E6%AD%A3%E5%88%99%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">ES9正则拓展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81import\"><span class=\"toc-text\">动态import</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#globalThis\"><span class=\"toc-text\">globalThis</span></a></li></ol>","author":{"name":"Luo","slug":"blog-author","avatar":"https://w.wallhaven.cc/full/vq/wallhaven-vqdpzm.jpg","link":"/","description":"一名00后码农 <br /> @ <b>公众号：四夕白水</b>","socials":{"github":"https://github.com/TriDiamond","twitter":"","stackoverflow":"https://stackoverflow.org.cn/","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"","juejin":"https://juejin.cn/user/settings/profile","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"baidu":{"icon":"iconfont icon-baidu","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"book":{"icon":"far fa-address-book","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"}}}},"mapped":true,"prev_post":{"title":"git命令","uid":"e5c9682f958fbae18070afcafeff3ba8","slug":"git-1/git-1","date":"2020-09-15T10:49:36.000Z","updated":"2023-08-10T02:56:17.343Z","comments":true,"path":"api/articles/git-1/git-1.json","keywords":null,"cover":"/medias/g.jpg","text":"git 命令 第一次使用git 必须设置用户信息 git config --global user.name luohaozhe 设置用户邮箱 —设置成功后可以在本机找到用户目录下的.git开头文件查看 git config --global user.email luohaoz...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}],"author":{"name":"Luo","slug":"blog-author","avatar":"https://w.wallhaven.cc/full/vq/wallhaven-vqdpzm.jpg","link":"/","description":"一名00后码农 <br /> @ <b>公众号：四夕白水</b>","socials":{"github":"https://github.com/TriDiamond","twitter":"","stackoverflow":"https://stackoverflow.org.cn/","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"","juejin":"https://juejin.cn/user/settings/profile","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"baidu":{"icon":"iconfont icon-baidu","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"book":{"icon":"far fa-address-book","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"}}}},"feature":true},"next_post":{"title":"Vue从入门到进阶","uid":"3a5442cdd70fafdc822b61530fcd291c","slug":"Vue/Vue初始化","date":"2023-08-09T08:19:45.000Z","updated":"2023-08-15T07:10:41.379Z","comments":true,"path":"api/articles/Vue/Vue初始化.json","keywords":null,"cover":"/medias/1.jpg","text":"学习Vue之前要掌握的JavaScript:基础知识？ES6语法规范&#x2F;ES6模块化 1.默认导入与默认导出（一个文件只能使用一次默认导出） export default import 别名(随意符合规范) from &#39;文件地址&#39; 2.按需导入和按需导出（...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[],"tags":[{"name":"Vue","slug":"Vue","count":1,"path":"api/tags/Vue.json"}],"author":{"name":"Luo","slug":"blog-author","avatar":"https://w.wallhaven.cc/full/vq/wallhaven-vqdpzm.jpg","link":"/","description":"一名00后码农 <br /> @ <b>公众号：四夕白水</b>","socials":{"github":"https://github.com/TriDiamond","twitter":"","stackoverflow":"https://stackoverflow.org.cn/","wechat":"","qq":"","weibo":"https://weibo.com/","zhihu":"https://www.zhihu.com/","csdn":"","juejin":"https://juejin.cn/user/settings/profile","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"baidu":{"icon":"iconfont icon-baidu","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"},"book":{"icon":"far fa-address-book","link":"https://space.bilibili.com/1541391754?spm_id_from=333.788.0.0"}}}}}}